{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nimport { Keyboard } from \"foundation-sites\";\nvar focusGuardClass = \"focusguard\";\nvar focusableNodes = [\"A\", \"IFRAME\", \"OBJECT\", \"EMBED\"];\nvar focusableDisableableNodes = [\"BUTTON\", \"INPUT\", \"TEXTAREA\", \"SELECT\"];\nvar FocusGuard = /*#__PURE__*/function () {\n  function FocusGuard(container) {\n    _classCallCheck(this, FocusGuard);\n    this.container = container;\n    this.guardedElement = null;\n  }\n  _createClass(FocusGuard, [{\n    key: \"trap\",\n    value: function trap(element) {\n      if (this.guardedElement) {\n        Keyboard.releaseFocus($(this.guardedElement));\n      }\n      this.enable();\n      this.guardedElement = element;\n\n      // Call the release focus first so that we don't accidentally add the\n      // keyboard trap twice. Note that the Foundation methods expect the elements\n      // to be jQuery elements which is why we pass them through jQuery.\n      Keyboard.releaseFocus($(element));\n      Keyboard.trapFocus($(element));\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      var _this = this;\n      // Check if the guards already exists due to some other dialog\n      var guards = this.container.querySelectorAll(\":scope > .\".concat(focusGuardClass));\n      if (guards.length > 0) {\n        // Make sure the guards are the first and last element as there have\n        // been changes in the DOM.\n        guards.forEach(function (guard) {\n          if (guard.dataset.position === \"start\") {\n            _this.container.prepend(guard);\n          } else {\n            _this.container.append(guard);\n          }\n        });\n        return;\n      }\n\n      // Add guards at the start and end of the document and attach their focus\n      // listeners\n      var startGuard = this.createFocusGuard(\"start\");\n      var endGuard = this.createFocusGuard(\"end\");\n      this.container.prepend(startGuard);\n      this.container.append(endGuard);\n      startGuard.addEventListener(\"focus\", function () {\n        return _this.handleContainerFocus(startGuard);\n      });\n      endGuard.addEventListener(\"focus\", function () {\n        return _this.handleContainerFocus(endGuard);\n      });\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      var guards = this.container.querySelectorAll(\":scope > .\".concat(focusGuardClass));\n      guards.forEach(function (guard) {\n        return guard.remove();\n      });\n      if (this.guardedElement) {\n        // Note that the Foundation methods expect the elements to be jQuery\n        // elements which is why we pass them through jQuery.\n        Keyboard.releaseFocus($(this.guardedElement));\n        this.guardedElement = null;\n      }\n    }\n  }, {\n    key: \"createFocusGuard\",\n    value: function createFocusGuard(position) {\n      var guard = document.createElement(\"div\");\n      guard.className = focusGuardClass;\n      guard.dataset.position = position;\n      guard.tabIndex = 0;\n      guard.setAttribute(\"aria-hidden\", \"true\");\n      return guard;\n    }\n  }, {\n    key: \"handleContainerFocus\",\n    value: function handleContainerFocus(guard) {\n      var _this2 = this;\n      if (!this.guardedElement) {\n        guard.blur();\n        return;\n      }\n      var visibleNodes = Array.from(this.guardedElement.querySelectorAll(\"*\")).filter(function (item) {\n        return _this2.isVisible(item);\n      });\n      var target = null;\n      if (guard.dataset.position === \"start\") {\n        // Focus at the start guard, so focus the first focusable element after that\n        for (var ind = 0; ind < visibleNodes.length; ind += 1) {\n          if (!this.isFocusGuard(visibleNodes[ind]) && this.isFocusable(visibleNodes[ind])) {\n            target = visibleNodes[ind];\n            break;\n          }\n        }\n      } else {\n        // Focus at the end guard, so focus the first focusable element after that\n        for (var _ind = visibleNodes.length - 1; _ind >= 0; _ind -= 1) {\n          if (!this.isFocusGuard(visibleNodes[_ind]) && this.isFocusable(visibleNodes[_ind])) {\n            target = visibleNodes[_ind];\n            break;\n          }\n        }\n      }\n      if (target) {\n        target.focus();\n      } else {\n        // If no focusable element was found, blur the guard focus\n        guard.blur();\n      }\n    }\n  }, {\n    key: \"isVisible\",\n    value: function isVisible(element) {\n      return element.offsetWidth > 0 || element.offsetHeight > 0;\n    }\n  }, {\n    key: \"isFocusGuard\",\n    value: function isFocusGuard(element) {\n      return element.classList.contains(focusGuardClass);\n    }\n  }, {\n    key: \"isFocusable\",\n    value: function isFocusable(element) {\n      if (focusableNodes.indexOf(element.nodeName) > -1) {\n        return true;\n      }\n      if (focusableDisableableNodes.indexOf(element.nodeName) > -1 || element.getAttribute(\"contenteditable\")) {\n        if (element.getAttribute(\"disabled\")) {\n          return false;\n        }\n        return true;\n      }\n      var tabindex = parseInt(element.getAttribute(\"tabindex\"), 10);\n      if (!isNaN(tabindex) && tabindex >= 0) {\n        return true;\n      }\n      return false;\n    }\n  }]);\n  return FocusGuard;\n}();\nexport { FocusGuard as default };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,QAAQ,QAAQ,kBAAkB;AAE3C,IAAMC,eAAe,GAAG,YAAY;AACpC,IAAMC,cAAc,GAAG,CAAC,GAAG,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,CAAC;AACzD,IAAMC,yBAAyB,GAAG,CAAC,QAAQ,EAAE,OAAO,EAAE,UAAU,EAAE,QAAQ,CAAC;AAAC,IAEvDC,UAAU;EAC7B,oBAAYC,SAAS,EAAE;IAAAC;IACrB,IAAI,CAACD,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACE,cAAc,GAAG,IAAI;EAC5B;EAACC;IAAAC;IAAAC,OAED,cAAKC,OAAO,EAAE;MACZ,IAAI,IAAI,CAACJ,cAAc,EAAE;QACvBP,QAAQ,CAACY,YAAY,CAACC,CAAC,CAAC,IAAI,CAACN,cAAc,CAAC,CAAC;MAC/C;MAEA,IAAI,CAACO,MAAM,EAAE;MACb,IAAI,CAACP,cAAc,GAAGI,OAAO;;MAE7B;MACA;MACA;MACAX,QAAQ,CAACY,YAAY,CAACC,CAAC,CAACF,OAAO,CAAC,CAAC;MACjCX,QAAQ,CAACe,SAAS,CAACF,CAAC,CAACF,OAAO,CAAC,CAAC;IAChC;EAAC;IAAAF;IAAAC,OAED,kBAAS;MAAA;MACP;MACA,IAAMM,MAAM,GAAG,IAAI,CAACX,SAAS,CAACY,gBAAgB,qBAAchB,eAAe,EAAG;MAC9E,IAAIe,MAAM,CAACE,MAAM,GAAG,CAAC,EAAE;QACrB;QACA;QACAF,MAAM,CAACG,OAAO,CAAC,UAACC,KAAK,EAAK;UACxB,IAAIA,KAAK,CAACC,OAAO,CAACC,QAAQ,KAAK,OAAO,EAAE;YACtCC,KAAI,CAAClB,SAAS,CAACmB,OAAO,CAACJ,KAAK,CAAC;UAC/B,CAAC,MAAM;YACLG,KAAI,CAAClB,SAAS,CAACoB,MAAM,CAACL,KAAK,CAAC;UAC9B;QACF,CAAC,CAAC;QAEF;MACF;;MAEA;MACA;MACA,IAAMM,UAAU,GAAG,IAAI,CAACC,gBAAgB,CAAC,OAAO,CAAC;MACjD,IAAMC,QAAQ,GAAG,IAAI,CAACD,gBAAgB,CAAC,KAAK,CAAC;MAE7C,IAAI,CAACtB,SAAS,CAACmB,OAAO,CAACE,UAAU,CAAC;MAClC,IAAI,CAACrB,SAAS,CAACoB,MAAM,CAACG,QAAQ,CAAC;MAE/BF,UAAU,CAACG,gBAAgB,CAAC,OAAO,EAAE;QAAA,OAAMN,KAAI,CAACO,oBAAoB,CAACJ,UAAU,CAAC;MAAA,EAAC;MACjFE,QAAQ,CAACC,gBAAgB,CAAC,OAAO,EAAE;QAAA,OAAMN,KAAI,CAACO,oBAAoB,CAACF,QAAQ,CAAC;MAAA,EAAC;IAC/E;EAAC;IAAAnB;IAAAC,OAED,mBAAU;MACR,IAAMM,MAAM,GAAG,IAAI,CAACX,SAAS,CAACY,gBAAgB,qBAAchB,eAAe,EAAG;MAC9Ee,MAAM,CAACG,OAAO,CAAC,UAACC,KAAK;QAAA,OAAKA,KAAK,CAACW,MAAM,EAAE;MAAA,EAAC;MAEzC,IAAI,IAAI,CAACxB,cAAc,EAAE;QACvB;QACA;QACAP,QAAQ,CAACY,YAAY,CAACC,CAAC,CAAC,IAAI,CAACN,cAAc,CAAC,CAAC;QAC7C,IAAI,CAACA,cAAc,GAAG,IAAI;MAC5B;IACF;EAAC;IAAAE;IAAAC,OAED,0BAAiBY,QAAQ,EAAE;MACzB,IAAMF,KAAK,GAAGY,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;MAC3Cb,KAAK,CAACc,SAAS,GAAGjC,eAAe;MACjCmB,KAAK,CAACC,OAAO,CAACC,QAAQ,GAAGA,QAAQ;MACjCF,KAAK,CAACe,QAAQ,GAAG,CAAC;MAClBf,KAAK,CAACgB,YAAY,CAAC,aAAa,EAAE,MAAM,CAAC;MAEzC,OAAOhB,KAAK;IACd;EAAC;IAAAX;IAAAC,OAED,8BAAqBU,KAAK,EAAE;MAAA;MAC1B,IAAI,CAAC,IAAI,CAACb,cAAc,EAAE;QACxBa,KAAK,CAACiB,IAAI,EAAE;QACZ;MACF;MAEA,IAAMC,YAAY,GAAGC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACjC,cAAc,CAACU,gBAAgB,CAAC,GAAG,CAAC,CAAC,CAACwB,MAAM,CAAC,UAACC,IAAI,EAAK;QAC1F,OAAOC,MAAI,CAACC,SAAS,CAACF,IAAI,CAAC;MAC7B,CAAC,CAAC;MAEF,IAAIG,MAAM,GAAG,IAAI;MACjB,IAAIzB,KAAK,CAACC,OAAO,CAACC,QAAQ,KAAK,OAAO,EAAE;QACtC;QACA,KAAK,IAAIwB,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGR,YAAY,CAACpB,MAAM,EAAE4B,GAAG,IAAI,CAAC,EAAE;UACrD,IAAI,CAAC,IAAI,CAACC,YAAY,CAACT,YAAY,CAACQ,GAAG,CAAC,CAAC,IAAI,IAAI,CAACE,WAAW,CAACV,YAAY,CAACQ,GAAG,CAAC,CAAC,EAAE;YAChFD,MAAM,GAAGP,YAAY,CAACQ,GAAG,CAAC;YAC1B;UACF;QACF;MACF,CAAC,MAAM;QACL;QACA,KAAK,IAAIA,IAAG,GAAGR,YAAY,CAACpB,MAAM,GAAG,CAAC,EAAE4B,IAAG,IAAI,CAAC,EAAEA,IAAG,IAAI,CAAC,EAAE;UAC1D,IAAI,CAAC,IAAI,CAACC,YAAY,CAACT,YAAY,CAACQ,IAAG,CAAC,CAAC,IAAI,IAAI,CAACE,WAAW,CAACV,YAAY,CAACQ,IAAG,CAAC,CAAC,EAAE;YAChFD,MAAM,GAAGP,YAAY,CAACQ,IAAG,CAAC;YAC1B;UACF;QACF;MACF;MAEA,IAAID,MAAM,EAAE;QACVA,MAAM,CAACI,KAAK,EAAE;MAChB,CAAC,MAAM;QACL;QACA7B,KAAK,CAACiB,IAAI,EAAE;MACd;IACF;EAAC;IAAA5B;IAAAC,OAED,mBAAUC,OAAO,EAAE;MACjB,OAAOA,OAAO,CAACuC,WAAW,GAAG,CAAC,IAAIvC,OAAO,CAACwC,YAAY,GAAG,CAAC;IAC5D;EAAC;IAAA1C;IAAAC,OAED,sBAAaC,OAAO,EAAE;MACpB,OAAOA,OAAO,CAACyC,SAAS,CAACC,QAAQ,CAACpD,eAAe,CAAC;IACpD;EAAC;IAAAQ;IAAAC,OAED,qBAAYC,OAAO,EAAE;MACnB,IAAIT,cAAc,CAACoD,OAAO,CAAC3C,OAAO,CAAC4C,QAAQ,CAAC,GAAG,CAAC,CAAC,EAAE;QACjD,OAAO,IAAI;MACb;MACA,IAAIpD,yBAAyB,CAACmD,OAAO,CAAC3C,OAAO,CAAC4C,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAI5C,OAAO,CAAC6C,YAAY,CAAC,iBAAiB,CAAC,EAAE;QACvG,IAAI7C,OAAO,CAAC6C,YAAY,CAAC,UAAU,CAAC,EAAE;UACpC,OAAO,KAAK;QACd;QACA,OAAO,IAAI;MACb;MAEA,IAAMC,QAAQ,GAAGC,QAAQ,CAAC/C,OAAO,CAAC6C,YAAY,CAAC,UAAU,CAAC,EAAE,EAAE,CAAC;MAC/D,IAAI,CAACG,KAAK,CAACF,QAAQ,CAAC,IAAIA,QAAQ,IAAI,CAAC,EAAE;QACrC,OAAO,IAAI;MACb;MAEA,OAAO,KAAK;IACd;EAAC;EAAA;AAAA;AAAA,SAtIkBrD,UAAU","names":["Keyboard","focusGuardClass","focusableNodes","focusableDisableableNodes","FocusGuard","container","_classCallCheck","guardedElement","_createClass","key","value","element","releaseFocus","$","enable","trapFocus","guards","querySelectorAll","length","forEach","guard","dataset","position","_this","prepend","append","startGuard","createFocusGuard","endGuard","addEventListener","handleContainerFocus","remove","document","createElement","className","tabIndex","setAttribute","blur","visibleNodes","Array","from","filter","item","_this2","isVisible","target","ind","isFocusGuard","isFocusable","focus","offsetWidth","offsetHeight","classList","contains","indexOf","nodeName","getAttribute","tabindex","parseInt","isNaN"],"sources":["/home/alan/.rvm/gems/ruby-3.0.3/gems/decidim-core-0.27.0/app/packs/src/decidim/focus_guard.js"],"sourcesContent":["import { Keyboard } from \"foundation-sites\"\n\nconst focusGuardClass = \"focusguard\";\nconst focusableNodes = [\"A\", \"IFRAME\", \"OBJECT\", \"EMBED\"];\nconst focusableDisableableNodes = [\"BUTTON\", \"INPUT\", \"TEXTAREA\", \"SELECT\"];\n\nexport default class FocusGuard {\n  constructor(container) {\n    this.container = container;\n    this.guardedElement = null;\n  }\n\n  trap(element) {\n    if (this.guardedElement) {\n      Keyboard.releaseFocus($(this.guardedElement));\n    }\n\n    this.enable();\n    this.guardedElement = element;\n\n    // Call the release focus first so that we don't accidentally add the\n    // keyboard trap twice. Note that the Foundation methods expect the elements\n    // to be jQuery elements which is why we pass them through jQuery.\n    Keyboard.releaseFocus($(element));\n    Keyboard.trapFocus($(element));\n  }\n\n  enable() {\n    // Check if the guards already exists due to some other dialog\n    const guards = this.container.querySelectorAll(`:scope > .${focusGuardClass}`);\n    if (guards.length > 0) {\n      // Make sure the guards are the first and last element as there have\n      // been changes in the DOM.\n      guards.forEach((guard) => {\n        if (guard.dataset.position === \"start\") {\n          this.container.prepend(guard);\n        } else {\n          this.container.append(guard);\n        }\n      })\n\n      return;\n    }\n\n    // Add guards at the start and end of the document and attach their focus\n    // listeners\n    const startGuard = this.createFocusGuard(\"start\");\n    const endGuard = this.createFocusGuard(\"end\");\n\n    this.container.prepend(startGuard);\n    this.container.append(endGuard);\n\n    startGuard.addEventListener(\"focus\", () => this.handleContainerFocus(startGuard));\n    endGuard.addEventListener(\"focus\", () => this.handleContainerFocus(endGuard));\n  }\n\n  disable() {\n    const guards = this.container.querySelectorAll(`:scope > .${focusGuardClass}`);\n    guards.forEach((guard) => guard.remove());\n\n    if (this.guardedElement) {\n      // Note that the Foundation methods expect the elements to be jQuery\n      // elements which is why we pass them through jQuery.\n      Keyboard.releaseFocus($(this.guardedElement));\n      this.guardedElement = null;\n    }\n  }\n\n  createFocusGuard(position) {\n    const guard = document.createElement(\"div\");\n    guard.className = focusGuardClass;\n    guard.dataset.position = position;\n    guard.tabIndex = 0;\n    guard.setAttribute(\"aria-hidden\", \"true\");\n\n    return guard;\n  };\n\n  handleContainerFocus(guard) {\n    if (!this.guardedElement) {\n      guard.blur();\n      return;\n    }\n\n    const visibleNodes = Array.from(this.guardedElement.querySelectorAll(\"*\")).filter((item) => {\n      return this.isVisible(item);\n    });\n\n    let target = null;\n    if (guard.dataset.position === \"start\") {\n      // Focus at the start guard, so focus the first focusable element after that\n      for (let ind = 0; ind < visibleNodes.length; ind += 1) {\n        if (!this.isFocusGuard(visibleNodes[ind]) && this.isFocusable(visibleNodes[ind])) {\n          target = visibleNodes[ind];\n          break;\n        }\n      }\n    } else {\n      // Focus at the end guard, so focus the first focusable element after that\n      for (let ind = visibleNodes.length - 1; ind >= 0; ind -= 1) {\n        if (!this.isFocusGuard(visibleNodes[ind]) && this.isFocusable(visibleNodes[ind])) {\n          target = visibleNodes[ind];\n          break;\n        }\n      }\n    }\n\n    if (target) {\n      target.focus();\n    } else {\n      // If no focusable element was found, blur the guard focus\n      guard.blur();\n    }\n  };\n\n  isVisible(element) {\n    return element.offsetWidth > 0 || element.offsetHeight > 0;\n  }\n\n  isFocusGuard(element) {\n    return element.classList.contains(focusGuardClass);\n  }\n\n  isFocusable(element) {\n    if (focusableNodes.indexOf(element.nodeName) > -1) {\n      return true;\n    }\n    if (focusableDisableableNodes.indexOf(element.nodeName) > -1 || element.getAttribute(\"contenteditable\")) {\n      if (element.getAttribute(\"disabled\")) {\n        return false;\n      }\n      return true;\n    }\n\n    const tabindex = parseInt(element.getAttribute(\"tabindex\"), 10);\n    if (!isNaN(tabindex) && tabindex >= 0) {\n      return true;\n    }\n\n    return false;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}