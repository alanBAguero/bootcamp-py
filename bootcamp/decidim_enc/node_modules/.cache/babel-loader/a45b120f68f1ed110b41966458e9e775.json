{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n/* eslint max-lines: [\"error\", {\"max\": 350, \"skipBlankLines\": true}] */\n\nvar COUNT_KEY = \"%count%\";\n// How often SR announces the message in relation to maximum characters. E.g.\n// if max characters is 1000, screen reader announces the remaining characters\n// every 100 (= 0.1 * 1000) characters. This will be \"floored\" to the closest\n// 100 if the maximum characters > 100. E.g. if max characters is 5500, the\n// threshold is 500 (= Math.floor(550 / 100) * 100). With 100 or less\n// characters, this ratio is omitted and the announce threshold is always set to\n// 10.\nvar SR_ANNOUNCE_THRESHOLD_RATIO = 0.1;\n// The number of characters left after which every keystroke will be announced.\nvar SR_ANNOUNCE_EVERY_THRESHOLD = 10;\nvar DEFAULT_MESSAGES = {\n  charactersAtLeast: {\n    one: \"at least \".concat(COUNT_KEY, \" character\"),\n    other: \"at least \".concat(COUNT_KEY, \" characters\")\n  },\n  charactersLeft: {\n    one: \"\".concat(COUNT_KEY, \" character left\"),\n    other: \"\".concat(COUNT_KEY, \" characters left\")\n  }\n};\nvar MESSAGES = DEFAULT_MESSAGES;\nvar InputCharacterCounter = /*#__PURE__*/function () {\n  function InputCharacterCounter(input) {\n    var _this = this;\n    _classCallCheck(this, InputCharacterCounter);\n    this.$input = input;\n    this.$target = $(this.$input.data(\"remaining-characters\"));\n    this.minCharacters = parseInt(this.$input.attr(\"minlength\"), 10);\n    this.maxCharacters = parseInt(this.$input.attr(\"maxlength\"), 10);\n    this.describeByCounter = typeof this.$input.attr(\"aria-describedby\") === \"undefined\";\n\n    // Define the closest length for the input \"gaps\" defined by the threshold.\n    if (this.maxCharacters > 10) {\n      if (this.maxCharacters > 100) {\n        this.announceThreshold = Math.floor(this.maxCharacters * SR_ANNOUNCE_THRESHOLD_RATIO);\n      } else {\n        this.announceThreshold = 10;\n      }\n\n      // The number of characters left after which every keystroke will be announced.\n      this.announceEveryThreshold = SR_ANNOUNCE_EVERY_THRESHOLD;\n    } else {\n      this.announceThreshold = 1;\n      this.announceEveryThreshold = 1;\n    }\n    var targetId = this.$target.attr(\"id\");\n    if (typeof targetId === \"undefined\") {\n      if (this.$input.attr(\"id\") && this.$input.attr(\"id\").length > 0) {\n        targetId = \"\".concat(this.$input.attr(\"id\"), \"_characters\");\n      } else {\n        targetId = \"characters_\".concat(Math.random().toString(36).substr(2, 9));\n      }\n    }\n    if (this.$target.length > 0) {\n      this.$target.attr(\"id\", targetId);\n    } else {\n      this.$target = $(\"<span id=\\\"\".concat(targetId, \"\\\" class=\\\"form-input-extra-before\\\" />\"));\n\n      // If input is a hidden for WYSIWYG editor add it at the end\n      if (this.$input.parent().is(\".editor\")) {\n        this.$input.parent().after(this.$target);\n      }\n      // Prefix and suffix columns are wrapped in columns, so put the\n      // character counter before that.\n      else if (this.$input.parent().is(\".columns\") && this.$input.parent().parent().is(\".row\")) {\n        this.$input.parent().parent().after(this.$target);\n      } else {\n        this.$input.after(this.$target);\n      }\n    }\n    if (this.$target.length > 0 && (this.maxCharacters > 0 || this.minCharacters > 0)) {\n      // Create the screen reader target element. We don't want to constantly\n      // announce every change to screen reader, only occasionally.\n      this.$srTarget = $(\"<span role=\\\"status\\\" id=\\\"\".concat(targetId, \"_sr\\\" class=\\\"show-for-sr remaining-character-count-sr\\\" />\"));\n      this.$target.before(this.$srTarget);\n      this.$target.attr(\"aria-hidden\", \"true\");\n      this.$userInput = this.$input;\n\n      // In WYSIWYG editors (Quill) we need to find the active editor from the\n      // DOM node. Quill has the experimental \"find\" method that should work\n      // fine in this case\n      if (Quill && this.$input.parent().is(\".editor\")) {\n        // Wait until the next javascript loop so Quill editors are created\n        setTimeout(function () {\n          _this.editor = Quill.find(_this.$input.siblings(\".editor-container\")[0]);\n          _this.$userInput = $(_this.editor.root);\n          _this.initialize();\n        });\n      } else {\n        this.initialize();\n      }\n    }\n  }\n  _createClass(InputCharacterCounter, [{\n    key: \"initialize\",\n    value: function initialize() {\n      this.updateInputLength();\n      this.previousInputLength = this.inputLength;\n      this.bindEvents();\n      this.setDescribedBy(true);\n    }\n  }, {\n    key: \"setDescribedBy\",\n    value: function setDescribedBy(active) {\n      if (!this.describeByCounter) {\n        return;\n      }\n      if (active) {\n        this.$userInput.attr(\"aria-describedby\", this.$srTarget.attr(\"id\"));\n      } else {\n        this.$userInput.removeAttr(\"aria-describedby\");\n      }\n    }\n  }, {\n    key: \"bindEvents\",\n    value: function bindEvents() {\n      var _this2 = this;\n      if (this.editor) {\n        this.editor.on(\"text-change\", function () {\n          _this2.handleInput();\n        });\n      } else {\n        this.$userInput.on(\"input\", function () {\n          _this2.handleInput();\n        });\n      }\n      this.$userInput.on(\"keyup\", function () {\n        _this2.updateStatus();\n      });\n      this.$userInput.on(\"focus\", function () {\n        _this2.updateScreenReaderStatus();\n      });\n      this.$userInput.on(\"blur\", function () {\n        _this2.updateScreenReaderStatus();\n        _this2.setDescribedBy(true);\n      });\n      if (this.$userInput.get(0) !== null) {\n        this.$userInput.get(0).addEventListener(\"emoji.added\", function () {\n          _this2.updateStatus();\n        });\n      }\n      this.updateStatus();\n      this.updateScreenReaderStatus();\n    }\n  }, {\n    key: \"getInputLength\",\n    value: function getInputLength() {\n      return this.inputLength;\n    }\n  }, {\n    key: \"updateInputLength\",\n    value: function updateInputLength() {\n      this.previousInputLength = this.inputLength;\n      if (this.editor) {\n        this.inputLength = this.editor.getLength();\n      } else {\n        this.inputLength = this.$input.val().length;\n      }\n    }\n  }, {\n    key: \"handleInput\",\n    value: function handleInput() {\n      this.updateInputLength();\n      this.checkScreenReaderUpdate();\n      // If the input is \"described by\" the character counter, some screen\n      // readers (NVDA) announce the status twice when it is updated. By\n      // removing the aria-describedby attribute while the user is typing makes\n      // the screen reader announce the status only once.\n      this.setDescribedBy(false);\n    }\n\n    /**\n     * This compares the current inputLength to the previous value and decides\n     * whether the user is currently adding or deleting characters from the view.\n     *\n     * @returns {String} The input direction either \"ins\" for insert or \"del\" for\n     *   delete.\n     */\n  }, {\n    key: \"getInputDirection\",\n    value: function getInputDirection() {\n      if (this.inputLength < this.previousInputLength) {\n        return \"del\";\n      }\n      return \"ins\";\n    }\n  }, {\n    key: \"getScreenReaderLength\",\n    value: function getScreenReaderLength() {\n      var currentLength = this.getInputLength();\n      if (this.maxCharacters < 10) {\n        return currentLength;\n      } else if (this.maxCharacters - currentLength <= this.announceEveryThreshold) {\n        return currentLength;\n      }\n      var srLength = currentLength - currentLength % this.announceThreshold;\n\n      // Prevent the screen reader telling too many characters left if the user\n      // deletes a characters. This can cause confusing experience e.g. when the\n      // user is closing the maximum amount of characters, so if the previous\n      // announcement was \"10 characters left\" and the user removes one character,\n      // the screen reader would announce \"100 characters left\" next time (when\n      // they actually have only 11 characters left). Similar when they are\n      // deleting a character at 900 characters, the screen reader would announce\n      // \"1000 characters left\" even when they only have 901 characters left.\n      if (this.getInputDirection() === \"del\") {\n        // The first branch makes sure that if the SR length matches the actual\n        // length, it will be always announced.\n        if (srLength === currentLength) {\n          return srLength;\n          // The second branch checks that if we are at the final threshold, we\n          // should not announce \"0 characters left\" when the user deletes more than\n          // the \"announce after every stroke\" limit (this.announceEveryThreshold).\n        } else if (this.maxCharacters - srLength === this.announceThreshold) {\n          return this.announcedAt || currentLength;\n          // The third branch checks that when deleting characters, we should\n          // announce the next threshold to get accurate annoucement. E.g. when we\n          // have 750 characters left and the user deletes 100 characters at once,\n          // we should announce \"700 characters left\" after that deletion.\n        } else if (srLength < currentLength) {\n          return srLength + this.announceThreshold;\n        }\n        // This fixes an issue in the following situation:\n        // 1. 750 characters left\n        // 2. Delete 100 characters in a row\n        // 3. SR: \"800 characters left\" (actual 850)\n        // 4. Type one additional character\n        // 5. Without this, SR would announce \"900 characters left\" = confusing\n      } else if (srLength < this.announcedAt) {\n        return this.announcedAt;\n      }\n      return srLength;\n    }\n  }, {\n    key: \"getMessages\",\n    value: function getMessages() {\n      var currentLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var showMessages = [];\n      var inputLength = currentLength;\n      if (inputLength === null) {\n        inputLength = this.getInputLength();\n      }\n      if (this.minCharacters > 0) {\n        var message = MESSAGES.charactersAtLeast.other;\n        if (this.minCharacters === 1) {\n          message = MESSAGES.charactersAtLeast.one;\n        }\n        showMessages.push(message.replace(COUNT_KEY, this.minCharacters));\n      }\n      if (this.maxCharacters > 0) {\n        var remaining = this.maxCharacters - inputLength;\n        var _message = MESSAGES.charactersLeft.other;\n        if (remaining === 1) {\n          _message = MESSAGES.charactersLeft.one;\n        }\n        this.$input[0].dispatchEvent(new CustomEvent(\"characterCounter\", {\n          detail: {\n            remaining: remaining\n          }\n        }));\n        showMessages.push(_message.replace(COUNT_KEY, remaining));\n      }\n      return showMessages;\n    }\n  }, {\n    key: \"updateStatus\",\n    value: function updateStatus() {\n      this.$target.text(this.getMessages().join(\", \"));\n    }\n  }, {\n    key: \"checkScreenReaderUpdate\",\n    value: function checkScreenReaderUpdate() {\n      if (this.maxCharacters < 1) {\n        return;\n      }\n      var currentLength = this.getScreenReaderLength();\n      if (currentLength === this.announcedAt) {\n        return;\n      }\n      this.announcedAt = currentLength;\n      this.updateScreenReaderStatus(currentLength);\n    }\n  }, {\n    key: \"updateScreenReaderStatus\",\n    value: function updateScreenReaderStatus() {\n      var currentLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      this.$srTarget.text(this.getMessages(currentLength).join(\", \"));\n    }\n  }], [{\n    key: \"configureMessages\",\n    value: function configureMessages(messages) {\n      MESSAGES = $.extend(DEFAULT_MESSAGES, messages);\n    }\n  }]);\n  return InputCharacterCounter;\n}();\nexport { InputCharacterCounter as default };\nvar createCharacterCounter = function createCharacterCounter($input) {\n  if (typeof $input !== \"undefined\" && $input.length) {\n    $input.data(\"remaining-characters-counter\", new InputCharacterCounter($input));\n  }\n};\n$(function () {\n  $(\"input[type='text'], textarea, .editor>input[type='hidden']\").each(function (_i, elem) {\n    var $input = $(elem);\n    if (!$input.is(\"[minlength]\") && !$input.is(\"[maxlength]\")) {\n      return;\n    }\n    createCharacterCounter($input);\n  });\n});\nexport { InputCharacterCounter, createCharacterCounter };","map":{"version":3,"mappings":"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","names":["COUNT_KEY","SR_ANNOUNCE_THRESHOLD_RATIO","SR_ANNOUNCE_EVERY_THRESHOLD","DEFAULT_MESSAGES","charactersAtLeast","one","other","charactersLeft","MESSAGES","InputCharacterCounter","input","_classCallCheck","$input","$target","$","data","minCharacters","parseInt","attr","maxCharacters","describeByCounter","announceThreshold","Math","floor","announceEveryThreshold","targetId","length","random","toString","substr","parent","is","after","$srTarget","before","$userInput","Quill","setTimeout","_this","editor","find","siblings","root","initialize","_createClass","key","value","updateInputLength","previousInputLength","inputLength","bindEvents","setDescribedBy","active","removeAttr","on","_this2","handleInput","updateStatus","updateScreenReaderStatus","get","addEventListener","getLength","val","checkScreenReaderUpdate","currentLength","getInputLength","srLength","getInputDirection","announcedAt","showMessages","message","push","replace","remaining","dispatchEvent","CustomEvent","detail","text","getMessages","join","getScreenReaderLength","messages","extend","createCharacterCounter","each","_i","elem"],"sources":["/home/alan/.rvm/gems/ruby-3.0.3/gems/decidim-core-0.27.0/app/packs/src/decidim/input_character_counter.js"],"sourcesContent":["/* eslint max-lines: [\"error\", {\"max\": 350, \"skipBlankLines\": true}] */\n\nconst COUNT_KEY = \"%count%\";\n// How often SR announces the message in relation to maximum characters. E.g.\n// if max characters is 1000, screen reader announces the remaining characters\n// every 100 (= 0.1 * 1000) characters. This will be \"floored\" to the closest\n// 100 if the maximum characters > 100. E.g. if max characters is 5500, the\n// threshold is 500 (= Math.floor(550 / 100) * 100). With 100 or less\n// characters, this ratio is omitted and the announce threshold is always set to\n// 10.\nconst SR_ANNOUNCE_THRESHOLD_RATIO = 0.1;\n// The number of characters left after which every keystroke will be announced.\nconst SR_ANNOUNCE_EVERY_THRESHOLD = 10;\nconst DEFAULT_MESSAGES = {\n  charactersAtLeast: {\n    one: `at least ${COUNT_KEY} character`,\n    other: `at least ${COUNT_KEY} characters`\n  },\n  charactersLeft: {\n    one: `${COUNT_KEY} character left`,\n    other: `${COUNT_KEY} characters left`\n  }\n};\nlet MESSAGES = DEFAULT_MESSAGES;\n\nexport default class InputCharacterCounter {\n  static configureMessages(messages) {\n    MESSAGES = $.extend(DEFAULT_MESSAGES, messages);\n  }\n\n  constructor(input) {\n    this.$input = input;\n    this.$target = $(this.$input.data(\"remaining-characters\"));\n    this.minCharacters = parseInt(this.$input.attr(\"minlength\"), 10);\n    this.maxCharacters = parseInt(this.$input.attr(\"maxlength\"), 10);\n    this.describeByCounter = typeof this.$input.attr(\"aria-describedby\") === \"undefined\";\n\n    // Define the closest length for the input \"gaps\" defined by the threshold.\n    if (this.maxCharacters > 10) {\n      if (this.maxCharacters > 100) {\n        this.announceThreshold = Math.floor(this.maxCharacters * SR_ANNOUNCE_THRESHOLD_RATIO);\n      } else {\n        this.announceThreshold = 10;\n      }\n\n      // The number of characters left after which every keystroke will be announced.\n      this.announceEveryThreshold = SR_ANNOUNCE_EVERY_THRESHOLD;\n    } else {\n      this.announceThreshold = 1;\n      this.announceEveryThreshold = 1;\n    }\n\n    let targetId = this.$target.attr(\"id\");\n    if (typeof targetId === \"undefined\") {\n      if (this.$input.attr(\"id\") && this.$input.attr(\"id\").length > 0) {\n        targetId = `${this.$input.attr(\"id\")}_characters`;\n      } else {\n        targetId = `characters_${Math.random().toString(36).substr(2, 9)}`;\n      }\n    }\n\n    if (this.$target.length > 0) {\n      this.$target.attr(\"id\", targetId)\n    } else {\n      this.$target = $(`<span id=\"${targetId}\" class=\"form-input-extra-before\" />`)\n\n      // If input is a hidden for WYSIWYG editor add it at the end\n      if (this.$input.parent().is(\".editor\")) {\n        this.$input.parent().after(this.$target);\n      }\n      // Prefix and suffix columns are wrapped in columns, so put the\n      // character counter before that.\n      else if (\n        this.$input.parent().is(\".columns\") &&\n        this.$input.parent().parent().is(\".row\")\n      ) {\n        this.$input.parent().parent().after(this.$target);\n      } else {\n        this.$input.after(this.$target);\n      }\n    }\n\n    if (this.$target.length > 0 && (this.maxCharacters > 0 || this.minCharacters > 0)) {\n      // Create the screen reader target element. We don't want to constantly\n      // announce every change to screen reader, only occasionally.\n      this.$srTarget = $(\n        `<span role=\"status\" id=\"${targetId}_sr\" class=\"show-for-sr remaining-character-count-sr\" />`\n      );\n      this.$target.before(this.$srTarget);\n      this.$target.attr(\"aria-hidden\", \"true\");\n\n      this.$userInput = this.$input;\n\n      // In WYSIWYG editors (Quill) we need to find the active editor from the\n      // DOM node. Quill has the experimental \"find\" method that should work\n      // fine in this case\n      if (Quill && this.$input.parent().is(\".editor\")) {\n        // Wait until the next javascript loop so Quill editors are created\n        setTimeout(() => {\n          this.editor = Quill.find(this.$input.siblings(\".editor-container\")[0]);\n          this.$userInput = $(this.editor.root);\n          this.initialize();\n        });\n      } else {\n        this.initialize();\n      }\n    }\n  }\n\n  initialize() {\n    this.updateInputLength();\n    this.previousInputLength = this.inputLength;\n\n    this.bindEvents();\n    this.setDescribedBy(true);\n  }\n\n  setDescribedBy(active) {\n    if (!this.describeByCounter) {\n      return;\n    }\n\n    if (active) {\n      this.$userInput.attr(\"aria-describedby\", this.$srTarget.attr(\"id\"));\n    } else {\n      this.$userInput.removeAttr(\"aria-describedby\");\n    }\n  }\n\n  bindEvents() {\n    if (this.editor) {\n      this.editor.on(\"text-change\", () => {\n        this.handleInput();\n      });\n    } else {\n      this.$userInput.on(\"input\", () => {\n        this.handleInput();\n      });\n    }\n\n    this.$userInput.on(\"keyup\", () => {\n      this.updateStatus();\n    });\n    this.$userInput.on(\"focus\", () => {\n      this.updateScreenReaderStatus();\n    });\n    this.$userInput.on(\"blur\", () => {\n      this.updateScreenReaderStatus();\n      this.setDescribedBy(true);\n    });\n    if (this.$userInput.get(0) !== null) {\n      this.$userInput.get(0).addEventListener(\"emoji.added\", () => {\n        this.updateStatus();\n      });\n    }\n    this.updateStatus();\n    this.updateScreenReaderStatus();\n  }\n\n  getInputLength() {\n    return this.inputLength;\n  }\n\n  updateInputLength() {\n    this.previousInputLength = this.inputLength;\n    if (this.editor) {\n      this.inputLength = this.editor.getLength();\n    } else {\n      this.inputLength = this.$input.val().length;\n    }\n  }\n\n  handleInput() {\n    this.updateInputLength();\n    this.checkScreenReaderUpdate();\n    // If the input is \"described by\" the character counter, some screen\n    // readers (NVDA) announce the status twice when it is updated. By\n    // removing the aria-describedby attribute while the user is typing makes\n    // the screen reader announce the status only once.\n    this.setDescribedBy(false);\n  }\n\n  /**\n   * This compares the current inputLength to the previous value and decides\n   * whether the user is currently adding or deleting characters from the view.\n   *\n   * @returns {String} The input direction either \"ins\" for insert or \"del\" for\n   *   delete.\n   */\n  getInputDirection() {\n    if (this.inputLength < this.previousInputLength) {\n      return \"del\";\n    }\n\n    return \"ins\";\n  }\n\n  getScreenReaderLength() {\n    const currentLength = this.getInputLength();\n    if (this.maxCharacters < 10) {\n      return currentLength;\n    } else if (this.maxCharacters - currentLength <= this.announceEveryThreshold) {\n      return currentLength;\n    }\n\n    const srLength = currentLength - currentLength % this.announceThreshold;\n\n    // Prevent the screen reader telling too many characters left if the user\n    // deletes a characters. This can cause confusing experience e.g. when the\n    // user is closing the maximum amount of characters, so if the previous\n    // announcement was \"10 characters left\" and the user removes one character,\n    // the screen reader would announce \"100 characters left\" next time (when\n    // they actually have only 11 characters left). Similar when they are\n    // deleting a character at 900 characters, the screen reader would announce\n    // \"1000 characters left\" even when they only have 901 characters left.\n    if (this.getInputDirection() === \"del\") {\n      // The first branch makes sure that if the SR length matches the actual\n      // length, it will be always announced.\n      if (srLength === currentLength) {\n        return srLength;\n      // The second branch checks that if we are at the final threshold, we\n      // should not announce \"0 characters left\" when the user deletes more than\n      // the \"announce after every stroke\" limit (this.announceEveryThreshold).\n      } else if (this.maxCharacters - srLength === this.announceThreshold) {\n        return this.announcedAt || currentLength;\n      // The third branch checks that when deleting characters, we should\n      // announce the next threshold to get accurate annoucement. E.g. when we\n      // have 750 characters left and the user deletes 100 characters at once,\n      // we should announce \"700 characters left\" after that deletion.\n      } else if (srLength < currentLength) {\n        return srLength + this.announceThreshold;\n      }\n    // This fixes an issue in the following situation:\n    // 1. 750 characters left\n    // 2. Delete 100 characters in a row\n    // 3. SR: \"800 characters left\" (actual 850)\n    // 4. Type one additional character\n    // 5. Without this, SR would announce \"900 characters left\" = confusing\n    } else if (srLength < this.announcedAt) {\n      return this.announcedAt;\n    }\n\n    return srLength;\n  }\n\n  getMessages(currentLength = null) {\n    const showMessages = [];\n    let inputLength = currentLength;\n    if (inputLength === null) {\n      inputLength = this.getInputLength()\n    }\n\n    if (this.minCharacters > 0) {\n      let message = MESSAGES.charactersAtLeast.other;\n      if (this.minCharacters === 1) {\n        message = MESSAGES.charactersAtLeast.one;\n      }\n      showMessages.push(message.replace(COUNT_KEY, this.minCharacters));\n    }\n\n    if (this.maxCharacters > 0) {\n      const remaining = this.maxCharacters - inputLength;\n      let message = MESSAGES.charactersLeft.other;\n      if (remaining === 1) {\n        message = MESSAGES.charactersLeft.one;\n      }\n      this.$input[0].dispatchEvent(\n        new CustomEvent(\"characterCounter\", {detail: {remaining: remaining}})\n      );\n      showMessages.push(message.replace(COUNT_KEY, remaining));\n    }\n\n    return showMessages;\n  }\n\n  updateStatus() {\n    this.$target.text(this.getMessages().join(\", \"));\n  }\n\n  checkScreenReaderUpdate() {\n    if (this.maxCharacters < 1) {\n      return;\n    }\n\n    const currentLength = this.getScreenReaderLength();\n    if (currentLength === this.announcedAt) {\n      return;\n    }\n\n    this.announcedAt = currentLength;\n    this.updateScreenReaderStatus(currentLength);\n  }\n\n  updateScreenReaderStatus(currentLength = null) {\n    this.$srTarget.text(this.getMessages(currentLength).join(\", \"));\n  }\n}\n\nconst createCharacterCounter = ($input) => {\n  if (typeof $input !== \"undefined\" && $input.length) {\n    $input.data(\"remaining-characters-counter\", new InputCharacterCounter($input));\n  }\n}\n\n$(() => {\n  $(\"input[type='text'], textarea, .editor>input[type='hidden']\").each((_i, elem) => {\n    const $input = $(elem);\n\n    if (!$input.is(\"[minlength]\") && !$input.is(\"[maxlength]\")) {\n      return;\n    }\n\n    createCharacterCounter($input);\n  });\n});\n\nexport {InputCharacterCounter, createCharacterCounter};\n"]},"metadata":{},"sourceType":"module"}