{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport AutoComplete from \"src/decidim/autocomplete\";\n\n/**\n * This function can be used to create an autocomplete input automatically\n * from the following kind of div:\n *   <div data-autocomplete=\"{...}\"></div>\n *\n * The data-autocomplete attribute should contain the following configuration\n * as an encoded JSON, which is used to generate the AutoComplete options:\n * - name: assembly_member[user_id],\n * - options: [],\n * - placeholder: \"Select a participant\",\n * - searchURL: \"http://...\"\n * - selected: \"\",\n *\n * @param {HTMLElement} el The element to generate the autocomplete for.\n * @returns {AutoComplete} An instance of the AutoComplete class.\n */\nvar autoConfigure = function autoConfigure(el) {\n  var config = JSON.parse(el.dataset.autocomplete);\n  var searchUrl = new URL(config.searchURL);\n  var textInput = document.createElement(\"input\");\n  textInput.type = \"text\";\n  textInput.className = \"autocomplete-input\";\n  el.appendChild(textInput);\n  var mode = config.mode || \"sticky\";\n  var selected = null;\n  if (config.selected) {\n    switch (mode) {\n      case \"multi\":\n        selected = config.selected.map(function (item) {\n          return {\n            key: \"label\",\n            value: {\n              value: item.value,\n              label: item.label\n            }\n          };\n        });\n        break;\n      case \"sticky\":\n        selected = {\n          key: \"label\",\n          value: config.options[config.options.length - 1]\n        };\n        break;\n      default:\n        selected = config.selected;\n    }\n  }\n  var dataSource = function dataSource(query, callback) {\n    var params = new URLSearchParams(_objectSpread(_objectSpread({}, Object.fromEntries(searchUrl.searchParams)), {}, {\n      term: query\n    }));\n    fetch(\"\".concat(searchUrl.origin).concat(searchUrl.pathname, \"?\").concat(params.toString()), {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    }).then(function (response) {\n      return response.json();\n    }).then(function (data) {\n      callback(data);\n    });\n  };\n  var ac = new AutoComplete(textInput, {\n    name: config.name,\n    placeholder: config.placeholder,\n    selected: selected,\n    mode: mode,\n    searchPrompt: true,\n    searchPromptText: config.searchPromptText,\n    threshold: 3,\n    dataMatchKeys: [\"label\"],\n    dataSource: dataSource\n  });\n  return ac;\n};\n$(function () {\n  var $autocompleteDiv = $(\"[data-autocomplete]\");\n  if ($autocompleteDiv.length < 1) {\n    return;\n  }\n  $autocompleteDiv.each(function (_index, element) {\n    autoConfigure(element);\n  });\n});","map":{"version":3,"mappings":"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","names":["AutoComplete","autoConfigure","el","config","JSON","parse","dataset","autocomplete","searchUrl","URL","searchURL","textInput","document","createElement","type","className","appendChild","mode","selected","map","item","key","value","label","options","length","dataSource","query","callback","params","URLSearchParams","Object","fromEntries","searchParams","term","fetch","origin","pathname","toString","method","headers","then","response","json","data","ac","name","placeholder","searchPrompt","searchPromptText","threshold","dataMatchKeys","$","$autocompleteDiv","each","_index","element"],"sources":["/home/alan/.rvm/gems/ruby-3.0.3/gems/decidim-admin-0.27.0/app/packs/src/decidim/admin/admin_autocomplete.js"],"sourcesContent":["import AutoComplete from \"src/decidim/autocomplete\";\n\n/**\n * This function can be used to create an autocomplete input automatically\n * from the following kind of div:\n *   <div data-autocomplete=\"{...}\"></div>\n *\n * The data-autocomplete attribute should contain the following configuration\n * as an encoded JSON, which is used to generate the AutoComplete options:\n * - name: assembly_member[user_id],\n * - options: [],\n * - placeholder: \"Select a participant\",\n * - searchURL: \"http://...\"\n * - selected: \"\",\n *\n * @param {HTMLElement} el The element to generate the autocomplete for.\n * @returns {AutoComplete} An instance of the AutoComplete class.\n */\nconst autoConfigure = (el) => {\n  const config = JSON.parse(el.dataset.autocomplete);\n  const searchUrl = new URL(config.searchURL);\n  const textInput = document.createElement(\"input\");\n  textInput.type = \"text\";\n  textInput.className = \"autocomplete-input\";\n  el.appendChild(textInput);\n  let mode = config.mode || \"sticky\"\n  let selected = null;\n  if (config.selected) {\n    switch (mode) {\n    case \"multi\":\n      selected = config.selected.map((item) => (\n        {\n          key: \"label\",\n          value: {\n            value: item.value,\n            label: item.label\n          }\n        }\n      ));\n      break;\n    case \"sticky\":\n      selected = { key: \"label\", value: config.options[config.options.length - 1] };\n      break;\n    default:\n      selected = config.selected;\n    }\n  }\n\n  const dataSource = (query, callback) => {\n    const params = new URLSearchParams({\n      ...Object.fromEntries(searchUrl.searchParams),\n      term: query\n    });\n    fetch(`${searchUrl.origin}${searchUrl.pathname}?${params.toString()}`, {\n      method: \"GET\",\n      headers: { \"Content-Type\": \"application/json\" }\n    }).then((response) => response.json()).then((data) => {\n      callback(data)\n    });\n  };\n\n  const ac = new AutoComplete(textInput, {\n    name: config.name,\n    placeholder: config.placeholder,\n    selected: selected,\n    mode: mode,\n    searchPrompt: true,\n    searchPromptText: config.searchPromptText,\n    threshold: 3,\n    dataMatchKeys: [\"label\"],\n    dataSource\n  });\n\n  return ac;\n}\n\n$(() => {\n  const $autocompleteDiv = $(\"[data-autocomplete]\");\n  if ($autocompleteDiv.length < 1) {\n    return;\n  }\n\n  $autocompleteDiv.each((_index, element) => {\n    autoConfigure(element);\n  })\n})\n"]},"metadata":{},"sourceType":"module"}