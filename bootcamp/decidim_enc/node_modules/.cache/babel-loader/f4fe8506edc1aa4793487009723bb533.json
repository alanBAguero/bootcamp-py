{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nimport \"src/decidim/vendor/jquery-tmpl\";\nimport * as L from \"leaflet\";\nimport MapController from \"src/decidim/map/controller\";\nimport \"leaflet.markercluster\";\nvar MapMarkersController = /*#__PURE__*/function (_MapController) {\n  _inherits(MapMarkersController, _MapController);\n  var _super = _createSuper(MapMarkersController);\n  function MapMarkersController() {\n    _classCallCheck(this, MapMarkersController);\n    return _super.apply(this, arguments);\n  }\n  _createClass(MapMarkersController, [{\n    key: \"start\",\n    value: function start() {\n      this.markerClusters = null;\n      if (Array.isArray(this.config.markers) && this.config.markers.length > 0) {\n        this.addMarkers(this.config.markers);\n      } else {\n        this.map.fitWorld();\n      }\n    }\n  }, {\n    key: \"addMarkers\",\n    value: function addMarkers(markersData) {\n      var _this = this;\n      if (this.markerClusters === null) {\n        this.markerClusters = new L.MarkerClusterGroup();\n        this.map.addLayer(this.markerClusters);\n      }\n\n      // Pre-compiles the template\n      $.template(this.config.popupTemplateId, $(\"#\".concat(this.config.popupTemplateId)).html());\n      var bounds = new L.LatLngBounds(markersData.map(function (markerData) {\n        return [markerData.latitude, markerData.longitude];\n      }));\n      markersData.forEach(function (markerData) {\n        var marker = new L.Marker([markerData.latitude, markerData.longitude], {\n          icon: _this.createIcon(),\n          keyboard: true,\n          title: markerData.title\n        });\n        var node = document.createElement(\"div\");\n        $.tmpl(_this.config.popupTemplateId, markerData).appendTo(node);\n        marker.bindPopup(node, {\n          maxwidth: 640,\n          minWidth: 500,\n          keepInView: true,\n          className: \"map-info\"\n        }).openPopup();\n        _this.markerClusters.addLayer(marker);\n      });\n\n      // Make sure there is enough space in the map for the padding to be\n      // applied. Otherwise the map will automatically zoom out (test it on\n      // mobile). Make sure there is at least the same amount of width and\n      // height available on both sides + the padding (i.e. 4x padding in\n      // total).\n      var size = this.map.getSize();\n      if (size.y >= 400 && size.x >= 400) {\n        this.map.fitBounds(bounds, {\n          padding: [100, 100]\n        });\n      } else if (size.y >= 120 && size.x >= 120) {\n        this.map.fitBounds(bounds, {\n          padding: [30, 30]\n        });\n      } else {\n        this.map.fitBounds(bounds);\n      }\n    }\n  }, {\n    key: \"clearMarkers\",\n    value: function clearMarkers() {\n      this.map.removeLayer(this.markerClusters);\n      this.markerClusters = new L.MarkerClusterGroup();\n      this.map.addLayer(this.markerClusters);\n    }\n  }]);\n  return MapMarkersController;\n}(MapController);\nexport { MapMarkersController as default };","map":{"version":3,"mappings":"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","names":["L","MapController","MapMarkersController","_inherits","_classCallCheck","_createClass","key","value","markerClusters","Array","isArray","config","markers","length","addMarkers","map","fitWorld","markersData","MarkerClusterGroup","addLayer","$","template","popupTemplateId","html","bounds","LatLngBounds","markerData","latitude","longitude","forEach","marker","Marker","icon","_this","createIcon","keyboard","title","node","document","createElement","tmpl","appendTo","bindPopup","maxwidth","minWidth","keepInView","className","openPopup","size","getSize","y","x","fitBounds","padding","removeLayer"],"sources":["/home/alan/.rvm/gems/ruby-3.0.3/gems/decidim-core-0.27.0/app/packs/src/decidim/map/controller/markers.js"],"sourcesContent":["import \"src/decidim/vendor/jquery-tmpl\"\nimport * as L from \"leaflet\";\nimport MapController from \"src/decidim/map/controller\"\nimport \"leaflet.markercluster\";\n\nexport default class MapMarkersController extends MapController {\n  start() {\n    this.markerClusters = null;\n\n    if (Array.isArray(this.config.markers) && this.config.markers.length > 0) {\n      this.addMarkers(this.config.markers);\n    } else {\n      this.map.fitWorld();\n    }\n  }\n\n  addMarkers(markersData) {\n    if (this.markerClusters === null) {\n      this.markerClusters = new L.MarkerClusterGroup();\n      this.map.addLayer(this.markerClusters);\n    }\n\n    // Pre-compiles the template\n    $.template(\n      this.config.popupTemplateId,\n      $(`#${this.config.popupTemplateId}`).html()\n    );\n\n    const bounds = new L.LatLngBounds(\n      markersData.map(\n        (markerData) => [markerData.latitude, markerData.longitude]\n      )\n    );\n\n    markersData.forEach((markerData) => {\n      let marker = new L.Marker([markerData.latitude, markerData.longitude], {\n        icon: this.createIcon(),\n        keyboard: true,\n        title: markerData.title\n      });\n\n      let node = document.createElement(\"div\");\n\n      $.tmpl(this.config.popupTemplateId, markerData).appendTo(node);\n      marker.bindPopup(node, {\n        maxwidth: 640,\n        minWidth: 500,\n        keepInView: true,\n        className: \"map-info\"\n      }).openPopup();\n\n      this.markerClusters.addLayer(marker);\n    });\n\n    // Make sure there is enough space in the map for the padding to be\n    // applied. Otherwise the map will automatically zoom out (test it on\n    // mobile). Make sure there is at least the same amount of width and\n    // height available on both sides + the padding (i.e. 4x padding in\n    // total).\n    const size = this.map.getSize();\n    if (size.y >= 400 && size.x >= 400) {\n      this.map.fitBounds(bounds, { padding: [100, 100] });\n    } else if (size.y >= 120 && size.x >= 120) {\n      this.map.fitBounds(bounds, { padding: [30, 30] });\n    } else {\n      this.map.fitBounds(bounds);\n    }\n  }\n\n  clearMarkers() {\n    this.map.removeLayer(this.markerClusters);\n    this.markerClusters = new L.MarkerClusterGroup();\n    this.map.addLayer(this.markerClusters);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}