{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n/* eslint-disable no-div-regex, no-useless-escape, no-param-reassign, id-length */\n/* eslint max-lines: [\"error\", {\"max\": 350, \"skipBlankLines\": true}] */\n\n/**\n * A plain Javascript component that handles the form filter.\n * @class\n * @augments Component\n */\n\nimport delayed from \"src/decidim/delayed\";\nimport CheckBoxesTree from \"src/decidim/check_boxes_tree\";\nimport { registerCallback, unregisterCallback, pushState, replaceState, state } from \"src/decidim/history\";\nimport DataPicker from \"src/decidim/data_picker\";\nvar FormFilterComponent = /*#__PURE__*/function () {\n  function FormFilterComponent($form) {\n    _classCallCheck(this, FormFilterComponent);\n    this.$form = $form;\n    this.id = this.$form.attr(\"id\") || this._getUID();\n    this.mounted = false;\n    this.changeEvents = true;\n    this.theCheckBoxesTree = new CheckBoxesTree();\n    this.theDataPicker = window.theDataPicker || new DataPicker($(\".data-picker\"));\n    this._updateInitialState();\n    this._onFormChange = delayed(this, this._onFormChange.bind(this));\n    this._onPopState = this._onPopState.bind(this);\n    if (window.Decidim.PopStateHandler) {\n      this.popStateSubmiter = false;\n    } else {\n      this.popStateSubmiter = true;\n      window.Decidim.PopStateHandler = this.id;\n    }\n  }\n\n  /**\n   * Handles the logic for unmounting the component\n   * @public\n   * @returns {Void} - Returns nothing\n   */\n  _createClass(FormFilterComponent, [{\n    key: \"unmountComponent\",\n    value: function unmountComponent() {\n      if (this.mounted) {\n        this.mounted = false;\n        this.$form.off(\"change\", \"input, select\", this._onFormChange);\n        unregisterCallback(\"filters-\".concat(this.id));\n      }\n    }\n\n    /**\n     * Handles the logic for mounting the component\n     * @public\n     * @returns {Void} - Returns nothing\n     */\n  }, {\n    key: \"mountComponent\",\n    value: function mountComponent() {\n      var _this = this;\n      if (this.$form.length > 0 && !this.mounted) {\n        this.mounted = true;\n        var queue = 0;\n        var contentContainer = $(this.$form.closest(\".filters\").parent().find(\".skip\").attr(\"href\"));\n        if (contentContainer.length === 0 && this.$form.data(\"remoteFill\")) {\n          contentContainer = this.$form.data(\"remoteFill\");\n        }\n        this.$form.on(\"change\", \"input:not([data-disable-dynamic-change]), select:not([data-disable-dynamic-change])\", this._onFormChange);\n        this.currentFormRequest = null;\n        this.$form.on(\"ajax:beforeSend\", function (e) {\n          if (_this.currentFormRequest) {\n            _this.currentFormRequest.abort();\n          }\n          _this.currentFormRequest = e.originalEvent.detail[0];\n          queue += 1;\n          if (queue > 0 && contentContainer.length > 0 && !contentContainer.hasClass(\"spinner-container\")) {\n            contentContainer.addClass(\"spinner-container\");\n          }\n        });\n        this.$form.on(\"ajax:success\", function () {\n          queue -= 1;\n          if (queue <= 0 && contentContainer.length > 0) {\n            contentContainer.removeClass(\"spinner-container\");\n          }\n        });\n        this.$form.on(\"ajax:error\", function () {\n          queue -= 1;\n          if (queue <= 0 && contentContainer.length > 0) {\n            contentContainer.removeClass(\"spinner-container\");\n          }\n          _this.$form.find(\".spinner-container\").addClass(\"hide\");\n        });\n        this.theCheckBoxesTree.setContainerForm(this.$form);\n        registerCallback(\"filters-\".concat(this.id), function (currentState) {\n          _this._onPopState(currentState);\n        });\n      }\n    }\n\n    /**\n     * Sets path in the browser history with the initial filters state, to allow to restoring it when using browser history.\n     * @private\n     * @returns {Void} - Returns nothing.\n     */\n  }, {\n    key: \"_updateInitialState\",\n    value: function _updateInitialState() {\n      var _this$_currentStateAn = this._currentStateAndPath(),\n        _this$_currentStateAn2 = _slicedToArray(_this$_currentStateAn, 2),\n        initialPath = _this$_currentStateAn2[0],\n        initialState = _this$_currentStateAn2[1];\n      initialState._path = initialPath;\n      replaceState(null, initialState);\n    }\n\n    /**\n     * Finds the current location.\n     * @param {boolean} withHost - include the host part in the returned location\n     * @private\n     * @returns {String} - Returns the current location.\n     */\n  }, {\n    key: \"_getLocation\",\n    value: function _getLocation() {\n      var withHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var currentState = state();\n      var path = \"\";\n      if (currentState && currentState._path) {\n        path = currentState._path;\n      } else {\n        path = window.location.pathname + window.location.search + window.location.hash;\n      }\n      if (withHost) {\n        return window.location.origin + path;\n      }\n      return path;\n    }\n\n    /**\n     * Parse current location and get filter values.\n     * @private\n     * @returns {Object} - An object where a key correspond to a filter field\n     *                     and the value is the current value for the filter.\n     */\n  }, {\n    key: \"_parseLocationFilterValues\",\n    value: function _parseLocationFilterValues() {\n      // Every location param is constructed like this: filter[key]=value\n      var regexpResult = decodeURIComponent(this._getLocation()).match(/filter\\[([^\\]]*)\\](?:\\[\\])?=([^&]*)/g);\n\n      // The RegExp g flag returns null or an array of coincidences. It doesn't return the match groups\n      if (regexpResult) {\n        var filterParams = regexpResult.reduce(function (acc, result) {\n          var _result$match = result.match(/filter\\[([^\\]]*)\\](\\[\\])?=([^&]*)/),\n            _result$match2 = _slicedToArray(_result$match, 4),\n            key = _result$match2[1],\n            array = _result$match2[2],\n            value = _result$match2[3];\n          if (array) {\n            if (!acc[key]) {\n              acc[key] = [];\n            }\n            acc[key].push(value);\n          } else {\n            acc[key] = value;\n          }\n          return acc;\n        }, {});\n        return filterParams;\n      }\n      return null;\n    }\n\n    /**\n     * Parse current location and get the current order.\n     * @private\n     * @returns {string} - The current order\n     */\n  }, {\n    key: \"_parseLocationOrderValue\",\n    value: function _parseLocationOrderValue() {\n      var url = this._getLocation();\n      var match = url.match(/order=([^&]*)/);\n      var $orderMenu = this.$form.find(\".order-by .menu\");\n      var order = $orderMenu.find(\".menu a:first\").data(\"order\");\n      if (match) {\n        order = match[1];\n      }\n      return order;\n    }\n\n    /**\n     * Clears the form to start with a clean state.\n     * @private\n     * @returns {Void} - Returns nothing.\n     */\n  }, {\n    key: \"_clearForm\",\n    value: function _clearForm() {\n      var _this2 = this;\n      this.$form.find(\"input[type=checkbox]\").each(function (index, element) {\n        element.checked = element.indeterminate = false;\n      });\n      this.$form.find(\"input[type=radio]\").attr(\"checked\", false);\n      this.$form.find(\".data-picker\").each(function (_index, picker) {\n        _this2.theDataPicker.clear(picker);\n      });\n\n      // This ensure the form is reset in a valid state where a fieldset of\n      // radio buttons has the first selected.\n      this.$form.find(\"fieldset input[type=radio]:first\").each(function () {\n        // I need the this to iterate a jQuery collection\n        $(this)[0].checked = true; // eslint-disable-line no-invalid-this\n      });\n    }\n\n    /**\n     * Handles the logic when going back to a previous state in the filter form.\n     * @private\n     * @param {Object} currentState - state stored along with location URL\n     * @returns {Void} - Returns nothing.\n     */\n  }, {\n    key: \"_onPopState\",\n    value: function _onPopState(currentState) {\n      var _this3 = this;\n      this.changeEvents = false;\n      this._clearForm();\n      var filterParams = this._parseLocationFilterValues();\n      var currentOrder = this._parseLocationOrderValue();\n      this.$form.find(\"input.order_filter\").val(currentOrder);\n      if (filterParams) {\n        var fieldIds = Object.keys(filterParams);\n\n        // Iterate the filter params and set the correct form values\n        fieldIds.forEach(function (fieldName) {\n          var value = filterParams[fieldName];\n          if (Array.isArray(value)) {\n            var checkboxes = _this3.$form.find(\"input[type=checkbox][name=\\\"filter[\".concat(fieldName, \"][]\\\"]\"));\n            _this3.theCheckBoxesTree.updateChecked(checkboxes, value);\n          } else {\n            _this3.$form.find(\"*[name=\\\"filter[\".concat(fieldName, \"]\\\"]\")).each(function (index, element) {\n              switch (element.type) {\n                case \"hidden\":\n                  break;\n                case \"radio\":\n                case \"checkbox\":\n                  element.checked = value === element.value;\n                  break;\n                default:\n                  element.value = value;\n              }\n            });\n          }\n        });\n      }\n\n      // Retrieves picker information for selected values (value, text and link) from the state object\n      $(\".data-picker\", this.$form).each(function (_index, picker) {\n        var pickerState = currentState[picker.id];\n        if (pickerState) {\n          _this3.theDataPicker.load(picker, pickerState);\n        }\n      });\n\n      // Only one instance should submit the form on browser history navigation\n      if (this.popStateSubmiter) {\n        Rails.fire(this.$form[0], \"submit\");\n      }\n      this.changeEvents = true;\n    }\n\n    /**\n     * Handles the logic to update the current location after a form change event.\n     * @private\n     * @returns {Void} - Returns nothing.\n     */\n  }, {\n    key: \"_onFormChange\",\n    value: function _onFormChange() {\n      if (!this.changeEvents) {\n        return;\n      }\n      var _this$_currentStateAn3 = this._currentStateAndPath(),\n        _this$_currentStateAn4 = _slicedToArray(_this$_currentStateAn3, 2),\n        newPath = _this$_currentStateAn4[0],\n        newState = _this$_currentStateAn4[1];\n      var path = this._getLocation(false);\n      if (newPath === path) {\n        return;\n      }\n      Rails.fire(this.$form[0], \"submit\");\n      pushState(newPath, newState);\n      this._saveFilters(newPath);\n    }\n\n    /**\n     * Calculates the path and the state associated to the filters inputs.\n     * @private\n     * @returns {Array} - Returns an array with the path and the state for the current filters state.\n     */\n  }, {\n    key: \"_currentStateAndPath\",\n    value: function _currentStateAndPath() {\n      var _this4 = this;\n      var formAction = this.$form.attr(\"action\");\n      var params = this.$form.find(\":not(.ignore-filters)\").find(\"select:not(.ignore-filter), input:not(.ignore-filter)\").serialize();\n      var path = \"\";\n      var currentState = {};\n      if (formAction.indexOf(\"?\") < 0) {\n        path = \"\".concat(formAction, \"?\").concat(params);\n      } else {\n        path = \"\".concat(formAction, \"&\").concat(params);\n      }\n\n      // Stores picker information for selected values (value, text and link) in the currentState object\n      $(\".data-picker\", this.$form).each(function (_index, picker) {\n        currentState[picker.id] = _this4.theDataPicker.save(picker);\n      });\n      return [path, currentState];\n    }\n\n    /**\n     * Generates a unique identifier for the form.\n     * @private\n     * @returns {String} - Returns a unique identifier\n     */\n  }, {\n    key: \"_getUID\",\n    value: function _getUID() {\n      return \"filter-form-\".concat(new Date().setUTCMilliseconds(), \"-\").concat(Math.floor(Math.random() * 10000000));\n    }\n\n    /**\n     * Saves the changed filters on sessionStorage API.\n     * @private\n     * @param {string} pathWithQueryStrings - path with all the query strings for filter. To be used with backToListLink().\n     * @returns {Void} - Returns nothing.\n     */\n  }, {\n    key: \"_saveFilters\",\n    value: function _saveFilters(pathWithQueryStrings) {\n      if (!window.sessionStorage) {\n        return;\n      }\n      var pathName = this.$form.attr(\"action\");\n      sessionStorage.setItem(\"filteredParams\", JSON.stringify(_defineProperty({}, pathName, pathWithQueryStrings)));\n    }\n  }]);\n  return FormFilterComponent;\n}();\nexport { FormFilterComponent as default };","map":{"version":3,"mappings":"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","names":["delayed","CheckBoxesTree","registerCallback","unregisterCallback","pushState","replaceState","state","DataPicker","FormFilterComponent","$form","_classCallCheck","id","attr","_getUID","mounted","changeEvents","theCheckBoxesTree","theDataPicker","window","$","_updateInitialState","_onFormChange","bind","_onPopState","Decidim","PopStateHandler","popStateSubmiter","_createClass","key","value","off","length","queue","contentContainer","closest","parent","find","data","on","currentFormRequest","e","_this","abort","originalEvent","detail","hasClass","addClass","removeClass","setContainerForm","currentState","_currentStateAndPath","_this$_currentStateAn2","initialPath","initialState","_path","withHost","path","location","pathname","search","hash","origin","regexpResult","decodeURIComponent","_getLocation","match","filterParams","reduce","acc","result","_result$match2","array","push","url","$orderMenu","order","each","index","element","checked","indeterminate","_index","picker","_this2","clear","_clearForm","_parseLocationFilterValues","currentOrder","_parseLocationOrderValue","val","fieldIds","Object","keys","forEach","fieldName","Array","isArray","checkboxes","_this3","updateChecked","type","pickerState","load","Rails","fire","_this$_currentStateAn4","newPath","newState","_saveFilters","formAction","params","serialize","indexOf","_this4","save","Date","setUTCMilliseconds","Math","floor","random","pathWithQueryStrings","sessionStorage","pathName","setItem","JSON","stringify"],"sources":["/home/alan/.rvm/gems/ruby-3.0.3/gems/decidim-core-0.27.0/app/packs/src/decidim/form_filter.js"],"sourcesContent":["/* eslint-disable no-div-regex, no-useless-escape, no-param-reassign, id-length */\n/* eslint max-lines: [\"error\", {\"max\": 350, \"skipBlankLines\": true}] */\n\n/**\n * A plain Javascript component that handles the form filter.\n * @class\n * @augments Component\n */\n\nimport delayed from \"src/decidim/delayed\"\nimport CheckBoxesTree from \"src/decidim/check_boxes_tree\"\nimport { registerCallback, unregisterCallback, pushState, replaceState, state } from \"src/decidim/history\"\nimport DataPicker from \"src/decidim/data_picker\"\n\nexport default class FormFilterComponent {\n  constructor($form) {\n    this.$form = $form;\n    this.id = this.$form.attr(\"id\") || this._getUID();\n    this.mounted = false;\n    this.changeEvents = true;\n    this.theCheckBoxesTree = new CheckBoxesTree();\n    this.theDataPicker = window.theDataPicker || new DataPicker($(\".data-picker\"));\n\n    this._updateInitialState();\n    this._onFormChange = delayed(this, this._onFormChange.bind(this));\n    this._onPopState = this._onPopState.bind(this);\n\n    if (window.Decidim.PopStateHandler) {\n      this.popStateSubmiter = false;\n    } else {\n      this.popStateSubmiter = true;\n      window.Decidim.PopStateHandler = this.id;\n    }\n  }\n\n  /**\n   * Handles the logic for unmounting the component\n   * @public\n   * @returns {Void} - Returns nothing\n   */\n  unmountComponent() {\n    if (this.mounted) {\n      this.mounted = false;\n      this.$form.off(\"change\", \"input, select\", this._onFormChange);\n\n      unregisterCallback(`filters-${this.id}`)\n    }\n  }\n\n  /**\n   * Handles the logic for mounting the component\n   * @public\n   * @returns {Void} - Returns nothing\n   */\n  mountComponent() {\n    if (this.$form.length > 0 && !this.mounted) {\n      this.mounted = true;\n      let queue = 0;\n\n      let contentContainer = $(this.$form.closest(\".filters\").parent().find(\".skip\").attr(\"href\"));\n      if (contentContainer.length === 0 && this.$form.data(\"remoteFill\")) {\n        contentContainer = this.$form.data(\"remoteFill\");\n      }\n      this.$form.on(\"change\", \"input:not([data-disable-dynamic-change]), select:not([data-disable-dynamic-change])\", this._onFormChange);\n\n      this.currentFormRequest = null;\n      this.$form.on(\"ajax:beforeSend\", (e) => {\n        if (this.currentFormRequest) {\n          this.currentFormRequest.abort();\n        }\n        this.currentFormRequest = e.originalEvent.detail[0];\n        queue += 1;\n        if (queue > 0 && contentContainer.length > 0 && !contentContainer.hasClass(\"spinner-container\")) {\n          contentContainer.addClass(\"spinner-container\");\n        }\n      });\n\n      this.$form.on(\"ajax:success\", () => {\n        queue -= 1;\n        if (queue <= 0 && contentContainer.length > 0) {\n          contentContainer.removeClass(\"spinner-container\");\n        }\n      });\n\n      this.$form.on(\"ajax:error\", () => {\n        queue -= 1;\n        if (queue <= 0 && contentContainer.length > 0) {\n          contentContainer.removeClass(\"spinner-container\");\n        }\n        this.$form.find(\".spinner-container\").addClass(\"hide\");\n      });\n\n      this.theCheckBoxesTree.setContainerForm(this.$form);\n\n      registerCallback(`filters-${this.id}`, (currentState) => {\n        this._onPopState(currentState);\n      });\n    }\n  }\n\n  /**\n   * Sets path in the browser history with the initial filters state, to allow to restoring it when using browser history.\n   * @private\n   * @returns {Void} - Returns nothing.\n   */\n  _updateInitialState() {\n    const [initialPath, initialState] = this._currentStateAndPath();\n    initialState._path = initialPath\n    replaceState(null, initialState);\n  }\n\n  /**\n   * Finds the current location.\n   * @param {boolean} withHost - include the host part in the returned location\n   * @private\n   * @returns {String} - Returns the current location.\n   */\n  _getLocation(withHost = true) {\n    const currentState = state();\n    let path = \"\";\n\n    if (currentState && currentState._path) {\n      path = currentState._path;\n    } else {\n      path = window.location.pathname + window.location.search + window.location.hash;\n    }\n\n    if (withHost) {\n      return window.location.origin + path;\n    }\n    return path;\n  }\n\n  /**\n   * Parse current location and get filter values.\n   * @private\n   * @returns {Object} - An object where a key correspond to a filter field\n   *                     and the value is the current value for the filter.\n   */\n  _parseLocationFilterValues() {\n    // Every location param is constructed like this: filter[key]=value\n    let regexpResult = decodeURIComponent(this._getLocation()).match(/filter\\[([^\\]]*)\\](?:\\[\\])?=([^&]*)/g);\n\n    // The RegExp g flag returns null or an array of coincidences. It doesn't return the match groups\n    if (regexpResult) {\n      const filterParams = regexpResult.reduce((acc, result) => {\n        const [, key, array, value] = result.match(/filter\\[([^\\]]*)\\](\\[\\])?=([^&]*)/);\n        if (array) {\n          if (!acc[key]) {\n            acc[key] = [];\n          }\n          acc[key].push(value);\n        } else {\n          acc[key] = value;\n        }\n        return acc;\n      }, {});\n\n      return filterParams;\n    }\n\n    return null;\n  }\n\n  /**\n   * Parse current location and get the current order.\n   * @private\n   * @returns {string} - The current order\n   */\n  _parseLocationOrderValue() {\n    const url = this._getLocation();\n    const match = url.match(/order=([^&]*)/);\n    const $orderMenu = this.$form.find(\".order-by .menu\");\n    let order = $orderMenu.find(\".menu a:first\").data(\"order\");\n\n    if (match) {\n      order = match[1];\n    }\n\n    return order;\n  }\n\n  /**\n   * Clears the form to start with a clean state.\n   * @private\n   * @returns {Void} - Returns nothing.\n   */\n  _clearForm() {\n    this.$form.find(\"input[type=checkbox]\").each((index, element) => {\n      element.checked = element.indeterminate = false;\n    });\n    this.$form.find(\"input[type=radio]\").attr(\"checked\", false);\n    this.$form.find(\".data-picker\").each((_index, picker) => {\n      this.theDataPicker.clear(picker);\n    });\n\n    // This ensure the form is reset in a valid state where a fieldset of\n    // radio buttons has the first selected.\n    this.$form.find(\"fieldset input[type=radio]:first\").each(function () {\n      // I need the this to iterate a jQuery collection\n      $(this)[0].checked = true; // eslint-disable-line no-invalid-this\n    });\n  }\n\n  /**\n   * Handles the logic when going back to a previous state in the filter form.\n   * @private\n   * @param {Object} currentState - state stored along with location URL\n   * @returns {Void} - Returns nothing.\n   */\n  _onPopState(currentState) {\n    this.changeEvents = false;\n    this._clearForm();\n\n    const filterParams = this._parseLocationFilterValues();\n    const currentOrder = this._parseLocationOrderValue();\n\n    this.$form.find(\"input.order_filter\").val(currentOrder);\n\n    if (filterParams) {\n      const fieldIds = Object.keys(filterParams);\n\n      // Iterate the filter params and set the correct form values\n      fieldIds.forEach((fieldName) => {\n        let value = filterParams[fieldName];\n\n        if (Array.isArray(value)) {\n          let checkboxes = this.$form.find(`input[type=checkbox][name=\"filter[${fieldName}][]\"]`);\n          this.theCheckBoxesTree.updateChecked(checkboxes, value);\n        } else {\n          this.$form.find(`*[name=\"filter[${fieldName}]\"]`).each((index, element) => {\n            switch (element.type) {\n            case \"hidden\":\n              break;\n            case \"radio\":\n            case \"checkbox\":\n              element.checked = value === element.value;\n              break;\n            default:\n              element.value = value;\n            }\n          });\n        }\n      });\n    }\n\n    // Retrieves picker information for selected values (value, text and link) from the state object\n    $(\".data-picker\", this.$form).each((_index, picker) => {\n      let pickerState = currentState[picker.id];\n      if (pickerState) {\n        this.theDataPicker.load(picker, pickerState);\n      }\n    })\n\n    // Only one instance should submit the form on browser history navigation\n    if (this.popStateSubmiter) {\n      Rails.fire(this.$form[0], \"submit\");\n    }\n\n    this.changeEvents = true;\n  }\n\n  /**\n   * Handles the logic to update the current location after a form change event.\n   * @private\n   * @returns {Void} - Returns nothing.\n   */\n  _onFormChange() {\n    if (!this.changeEvents) {\n      return;\n    }\n\n    const [newPath, newState] = this._currentStateAndPath();\n    const path = this._getLocation(false);\n\n    if (newPath === path) {\n      return;\n    }\n\n    Rails.fire(this.$form[0], \"submit\");\n    pushState(newPath, newState);\n    this._saveFilters(newPath);\n  }\n\n  /**\n   * Calculates the path and the state associated to the filters inputs.\n   * @private\n   * @returns {Array} - Returns an array with the path and the state for the current filters state.\n   */\n  _currentStateAndPath() {\n    const formAction = this.$form.attr(\"action\");\n    const params = this.$form.find(\":not(.ignore-filters)\").find(\"select:not(.ignore-filter), input:not(.ignore-filter)\").serialize();\n\n    let path = \"\";\n    let currentState = {};\n\n    if (formAction.indexOf(\"?\") < 0) {\n      path = `${formAction}?${params}`;\n    } else {\n      path = `${formAction}&${params}`;\n    }\n\n    // Stores picker information for selected values (value, text and link) in the currentState object\n    $(\".data-picker\", this.$form).each((_index, picker) => {\n      currentState[picker.id] = this.theDataPicker.save(picker);\n    })\n\n    return [path, currentState];\n  }\n\n  /**\n   * Generates a unique identifier for the form.\n   * @private\n   * @returns {String} - Returns a unique identifier\n   */\n  _getUID() {\n    return `filter-form-${new Date().setUTCMilliseconds()}-${Math.floor(Math.random() * 10000000)}`;\n  }\n\n  /**\n   * Saves the changed filters on sessionStorage API.\n   * @private\n   * @param {string} pathWithQueryStrings - path with all the query strings for filter. To be used with backToListLink().\n   * @returns {Void} - Returns nothing.\n   */\n  _saveFilters(pathWithQueryStrings) {\n    if (!window.sessionStorage) {\n      return;\n    }\n\n    const pathName = this.$form.attr(\"action\");\n    sessionStorage.setItem(\"filteredParams\", JSON.stringify({[pathName]: pathWithQueryStrings}));\n  }\n\n}\n"]},"metadata":{},"sourceType":"module"}