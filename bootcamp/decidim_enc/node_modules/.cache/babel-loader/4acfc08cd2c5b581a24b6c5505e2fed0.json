{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n/* eslint-disable require-jsdoc */\n\nimport addEnterBindings from \"src/decidim/editor/modified_enter\";\nimport backspaceBindingsRangeAny from \"src/decidim/editor/modified_backspace_offset_any\";\nimport backspaceBindings from \"src/decidim/editor/modified_backspace_offset1\";\nimport HistoryOverride from \"src/decidim/editor/history_override\";\n\n// Disable warning messages from overwritting modules\nQuill.debug(\"error\");\n\n// It all started with these snippets of code: https://github.com/quilljs/quill/issues/252\nvar Delta = Quill[\"import\"](\"delta\");\nvar Break = Quill[\"import\"](\"blots/break\");\nvar Embed = Quill[\"import\"](\"blots/embed\");\nvar Scroll = Quill[\"import\"](\"blots/scroll\");\nvar Parchment = Quill[\"import\"](\"parchment\");\nQuill.register({\n  \"modules/history\": HistoryOverride\n}, true);\nvar icons = Quill[\"import\"](\"ui/icons\");\nicons.linebreak = \"⏎\";\nvar SmartBreak = /*#__PURE__*/function (_Break) {\n  _inherits(SmartBreak, _Break);\n  var _super = _createSuper(SmartBreak);\n  function SmartBreak() {\n    _classCallCheck(this, SmartBreak);\n    return _super.apply(this, arguments);\n  }\n  _createClass(SmartBreak, [{\n    key: \"length\",\n    value: function length() {\n      return 1;\n    }\n  }, {\n    key: \"value\",\n    value: function value() {\n      return \"\\n\";\n    }\n  }, {\n    key: \"insertInto\",\n    value: function insertInto(parent, ref) {\n      // Embed.prototype.insertInto.call(this, parent, ref);\n      Reflect.apply(Embed.prototype.insertInto, this, [parent, ref]);\n    }\n  }]);\n  return SmartBreak;\n}(Break);\nQuill.register(SmartBreak);\n\n// Override quill/blots/scroll.js\nvar ScrollOvderride = /*#__PURE__*/function (_Scroll) {\n  _inherits(ScrollOvderride, _Scroll);\n  var _super2 = _createSuper(ScrollOvderride);\n  function ScrollOvderride() {\n    _classCallCheck(this, ScrollOvderride);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(ScrollOvderride, [{\n    key: \"optimize\",\n    value: function optimize() {\n      var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this.batch === true) {\n        return;\n      }\n      this.parchmentOptimize(mutations, context);\n      if (mutations.length > 0) {\n        // quill/core/emitter.js, Emitter.events.SCROLL_OPTIMIZE = \"scroll-optimize\"\n        this.emitter.emit(\"scroll-optimize\", mutations, context);\n      }\n    }\n\n    // Override parchment/src/blot/scroll.ts\n  }, {\n    key: \"parchmentOptimize\",\n    value: function parchmentOptimize() {\n      var _this = this;\n      var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // super.optimize(context);\n      Reflect.apply(Parchment.Container.prototype.optimize, this, [context]);\n\n      // We must modify mutations directly, cannot make copy and then modify\n      // let records = [].slice.call(this.observer.takeRecords());\n      var records = _toConsumableArray(this.observer.takeRecords());\n      // Array.push currently seems to be implemented by a non-tail recursive function\n      // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n      var mark = function mark(blot, markParent) {\n        if (!blot || blot === _this) {\n          return;\n        }\n        if (!blot.domNode.parentNode) {\n          return;\n        }\n        if (blot.domNode.__blot && blot.domNode.__blot.mutations === null) {\n          blot.domNode.__blot.mutations = [];\n        }\n        if (markParent) {\n          mark(blot.parent);\n        }\n      };\n      var optimize = function optimize(blot) {\n        // Post-order traversal\n        if (!blot.domNode.__blot) {\n          return;\n        }\n        if (blot instanceof Parchment.Container) {\n          blot.children.forEach(optimize);\n        }\n        blot.optimize(context);\n      };\n      var remaining = mutations;\n      for (var ind = 0; remaining.length > 0; ind += 1) {\n        // MAX_OPTIMIZE_ITERATIONS = 100\n        if (ind >= 100) {\n          throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n        }\n        remaining.forEach(function (mutation) {\n          var blot = Parchment.find(mutation.target, true);\n          if (!blot) {\n            return;\n          }\n          if (blot.domNode === mutation.target) {\n            if (mutation.type === \"childList\") {\n              mark(Parchment.find(mutation.previousSibling, false));\n              mutation.addedNodes.forEach(function (node) {\n                var child = Parchment.find(node, false);\n                mark(child, false);\n                if (child instanceof Parchment.Container) {\n                  child.children.forEach(function (grandChild) {\n                    mark(grandChild, false);\n                  });\n                }\n              });\n            } else if (mutation.type === \"attributes\") {\n              mark(blot.prev);\n            }\n          }\n          mark(blot);\n        });\n        this.children.forEach(optimize);\n        remaining = _toConsumableArray(this.observer.takeRecords());\n        records = remaining.slice();\n        while (records.length > 0) {\n          mutations.push(records.pop());\n        }\n      }\n    }\n  }]);\n  return ScrollOvderride;\n}(Scroll);\n;\nQuill.register(\"blots/scroll\", ScrollOvderride, true);\nParchment.register(ScrollOvderride);\nexport default function lineBreakButtonHandler(quill) {\n  var range = quill.selection.getRange()[0];\n  var currentLeaf = quill.getLeaf(range.index)[0];\n  var nextLeaf = quill.getLeaf(range.index + 1)[0];\n  var previousChar = quill.getText(range.index - 1, 1);\n\n  // Insert a second break if:\n  // At the end of the editor, OR next leaf has a different parent (<p>)\n  if (nextLeaf === null || currentLeaf.parent !== nextLeaf.parent) {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  } else if (previousChar === \"\\n\") {\n    var delta = new Delta().retain(range.index).insert(\"\\n\");\n    quill.updateContents(delta, Quill.sources.USER);\n  } else {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  }\n\n  // Now that we've inserted a line break, move the cursor forward\n  quill.setSelection(range.index + 1, Quill.sources.SILENT);\n}\nQuill.register(\"modules/linebreak\", function (quill) {\n  quill.getModule(\"toolbar\").addHandler(\"linebreak\", function () {\n    lineBreakButtonHandler(quill);\n  });\n  quill.emitter.on(\"editor-ready\", function () {\n    var length = quill.getLength();\n    var text = quill.getText(length - 2, 2);\n\n    // Remove extraneous new lines\n    if (text === \"\\n\\n\") {\n      quill.deleteText(quill.getLength() - 2, 2);\n    }\n  });\n  quill.clipboard.addMatcher(\"BR\", function (node) {\n    var _node$parentNode;\n    if ((node === null || node === void 0 ? void 0 : (_node$parentNode = node.parentNode) === null || _node$parentNode === void 0 ? void 0 : _node$parentNode.tagName) === \"A\") {\n      return new Delta().insert(\"\\n\");\n    }\n    return new Delta().insert({\n      \"break\": \"\"\n    });\n  });\n  addEnterBindings(quill);\n  backspaceBindingsRangeAny(quill);\n  backspaceBindings(quill);\n  return;\n});","map":{"version":3,"mappings":"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","names":["addEnterBindings","backspaceBindingsRangeAny","backspaceBindings","HistoryOverride","Quill","debug","Delta","Break","Embed","Scroll","Parchment","register","icons","linebreak","SmartBreak","_inherits","_classCallCheck","_createClass","key","value","parent","ref","Reflect","apply","prototype","insertInto","ScrollOvderride","mutations","context","batch","parchmentOptimize","length","emitter","emit","Container","optimize","records","observer","takeRecords","push","pop","mark","blot","markParent","_this","domNode","parentNode","__blot","children","forEach","remaining","ind","Error","mutation","find","target","type","previousSibling","addedNodes","node","child","grandChild","prev","slice","lineBreakButtonHandler","quill","range","selection","getRange","currentLeaf","getLeaf","index","nextLeaf","previousChar","getText","insertEmbed","delta","retain","insert","updateContents","sources","USER","setSelection","SILENT","getModule","addHandler","on","getLength","text","deleteText","clipboard","addMatcher","_node$parentNode","tagName"],"sources":["/home/alan/.rvm/gems/ruby-3.0.3/gems/decidim-core-0.27.0/app/packs/src/decidim/editor/linebreak_module.js"],"sourcesContent":["/* eslint-disable require-jsdoc */\n\nimport addEnterBindings from \"src/decidim/editor/modified_enter\"\nimport backspaceBindingsRangeAny from \"src/decidim/editor/modified_backspace_offset_any\"\nimport backspaceBindings from \"src/decidim/editor/modified_backspace_offset1\"\nimport HistoryOverride from \"src/decidim/editor/history_override\"\n\n// Disable warning messages from overwritting modules\nQuill.debug(\"error\");\n\n// It all started with these snippets of code: https://github.com/quilljs/quill/issues/252\nconst Delta = Quill.import(\"delta\");\nconst Break = Quill.import(\"blots/break\");\nconst Embed = Quill.import(\"blots/embed\");\nconst Scroll = Quill.import(\"blots/scroll\");\nconst Parchment = Quill.import(\"parchment\");\nQuill.register({\"modules/history\": HistoryOverride}, true);\nlet icons = Quill.import(\"ui/icons\");\nicons.linebreak = \"⏎\";\n\nclass SmartBreak extends Break {\n  length() {\n    return 1;\n  }\n\n  value() {\n    return \"\\n\";\n  }\n\n  insertInto(parent, ref) {\n    // Embed.prototype.insertInto.call(this, parent, ref);\n    Reflect.apply(Embed.prototype.insertInto, this, [parent, ref]);\n  }\n}\nQuill.register(SmartBreak);\n\n// Override quill/blots/scroll.js\nclass ScrollOvderride extends Scroll {\n  optimize(mutations = [], context = {}) {\n    if (this.batch === true) {\n      return;\n    }\n\n    this.parchmentOptimize(mutations, context);\n\n    if (mutations.length > 0) {\n      // quill/core/emitter.js, Emitter.events.SCROLL_OPTIMIZE = \"scroll-optimize\"\n      this.emitter.emit(\"scroll-optimize\", mutations, context);\n    }\n  }\n\n  // Override parchment/src/blot/scroll.ts\n  parchmentOptimize(mutations = [], context = {}) {\n    // super.optimize(context);\n    Reflect.apply(Parchment.Container.prototype.optimize, this, [context]);\n\n    // We must modify mutations directly, cannot make copy and then modify\n    // let records = [].slice.call(this.observer.takeRecords());\n    let records = [...this.observer.takeRecords()];\n    // Array.push currently seems to be implemented by a non-tail recursive function\n    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n    while (records.length > 0) {\n      mutations.push(records.pop());\n    }\n    let mark = (blot, markParent) => {\n      if (!blot || blot === this) {\n        return;\n      }\n      if (!blot.domNode.parentNode) {\n        return;\n      }\n      if (blot.domNode.__blot && blot.domNode.__blot.mutations === null) {\n        blot.domNode.__blot.mutations = [];\n      }\n      if (markParent) {\n        mark(blot.parent);\n      }\n    };\n    let optimize = (blot) => {\n      // Post-order traversal\n      if (!blot.domNode.__blot) {\n        return;\n      }\n\n      if (blot instanceof Parchment.Container) {\n        blot.children.forEach(optimize);\n      }\n      blot.optimize(context);\n    };\n    let remaining = mutations;\n    for (let ind = 0; remaining.length > 0; ind += 1) {\n      // MAX_OPTIMIZE_ITERATIONS = 100\n      if (ind >= 100) {\n        throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n      }\n      remaining.forEach((mutation) => {\n        let blot = Parchment.find(mutation.target, true);\n        if (!blot) {\n          return;\n        }\n        if (blot.domNode === mutation.target) {\n          if (mutation.type === \"childList\") {\n            mark(Parchment.find(mutation.previousSibling, false));\n\n            mutation.addedNodes.forEach((node) => {\n              let child = Parchment.find(node, false);\n              mark(child, false);\n              if (child instanceof Parchment.Container) {\n                child.children.forEach(function(grandChild) {\n                  mark(grandChild, false);\n                });\n              }\n            });\n          } else if (mutation.type === \"attributes\") {\n            mark(blot.prev);\n          }\n        }\n        mark(blot);\n      });\n      this.children.forEach(optimize);\n      remaining = [...this.observer.takeRecords()];\n      records = remaining.slice();\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n    }\n  }\n};\nQuill.register(\"blots/scroll\", ScrollOvderride, true);\nParchment.register(ScrollOvderride);\n\n\nexport default function lineBreakButtonHandler(quill) {\n  let range = quill.selection.getRange()[0];\n  let currentLeaf = quill.getLeaf(range.index)[0];\n  let nextLeaf = quill.getLeaf(range.index + 1)[0];\n  const previousChar = quill.getText(range.index - 1, 1);\n\n  // Insert a second break if:\n  // At the end of the editor, OR next leaf has a different parent (<p>)\n  if (nextLeaf === null || (currentLeaf.parent !== nextLeaf.parent)) {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  } else if (previousChar === \"\\n\") {\n    const delta = new Delta().retain(range.index).insert(\"\\n\");\n    quill.updateContents(delta, Quill.sources.USER);\n  } else {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  }\n\n  // Now that we've inserted a line break, move the cursor forward\n  quill.setSelection(range.index + 1, Quill.sources.SILENT);\n}\n\nQuill.register(\"modules/linebreak\", (quill) => {\n  quill.getModule(\"toolbar\").addHandler(\"linebreak\", () => {\n    lineBreakButtonHandler(quill);\n  });\n\n  quill.emitter.on(\"editor-ready\", () => {\n    const length = quill.getLength();\n    const text = quill.getText(length - 2, 2);\n\n    // Remove extraneous new lines\n    if (text === \"\\n\\n\") {\n      quill.deleteText(quill.getLength() - 2, 2);\n    }\n  });\n\n  quill.clipboard.addMatcher(\"BR\", (node) => {\n    if (node?.parentNode?.tagName === \"A\") {\n      return new Delta().insert(\"\\n\");\n    }\n    return new Delta().insert({\"break\": \"\"});\n  });\n\n  addEnterBindings(quill);\n  backspaceBindingsRangeAny(quill);\n  backspaceBindings(quill);\n\n  return;\n});\n\n"]},"metadata":{},"sourceType":"module"}