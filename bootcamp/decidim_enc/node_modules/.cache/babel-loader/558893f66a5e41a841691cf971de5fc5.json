{"ast":null,"code":"/* eslint-disable */\n\n/*\n * jQuery Templating Plugin\n * Copyright 2010, John Resig\n * Dual licensed under the MIT or GPL Version 2 licenses.\n */\n;\n(function (jQuery, undefined) {\n  var oldManip = jQuery.fn.domManip,\n    tmplItmAtt = \"_tmplitem\",\n    htmlExpr = /^[^<]*(<[\\w\\W]+>)[^>]*$|\\{\\{\\! /,\n    newTmplItems = {},\n    wrappedItems = {},\n    appendToTmplItems,\n    topTmplItem = {\n      key: 0,\n      data: {}\n    },\n    itemKey = 0,\n    cloneIndex = 0,\n    stack = [];\n  function newTmplItem(options, parentItem, fn, data) {\n    // Returns a template item data structure for a new rendered instance of a template (a 'template item').\n    // The content field is a hierarchical array of strings and nested items (to be\n    // removed and replaced by nodes field of dom elements, once inserted in DOM).\n    var newItem = {\n      data: data || (parentItem ? parentItem.data : {}),\n      _wrap: parentItem ? parentItem._wrap : null,\n      tmpl: null,\n      parent: parentItem || null,\n      nodes: [],\n      calls: tiCalls,\n      nest: tiNest,\n      wrap: tiWrap,\n      html: tiHtml,\n      update: tiUpdate\n    };\n    if (options) {\n      jQuery.extend(newItem, options, {\n        nodes: [],\n        parent: parentItem\n      });\n    }\n    if (fn) {\n      // Build the hierarchical content to be used during insertion into DOM\n      newItem.tmpl = fn;\n      newItem._ctnt = newItem._ctnt || newItem.tmpl(jQuery, newItem);\n      newItem.key = ++itemKey;\n      // Keep track of new template item, until it is stored as jQuery Data on DOM element\n      (stack.length ? wrappedItems : newTmplItems)[itemKey] = newItem;\n    }\n    return newItem;\n  }\n\n  // Override appendTo etc., in order to provide support for targeting multiple elements. (This code would disappear if integrated in jquery core).\n  jQuery.each({\n    appendTo: \"append\",\n    prependTo: \"prepend\",\n    insertBefore: \"before\",\n    insertAfter: \"after\",\n    replaceAll: \"replaceWith\"\n  }, function (name, original) {\n    jQuery.fn[name] = function (selector) {\n      var ret = [],\n        insert = jQuery(selector),\n        elems,\n        i,\n        l,\n        tmplItems,\n        parent = this.length === 1 && this[0].parentNode;\n      appendToTmplItems = newTmplItems || {};\n      if (parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1) {\n        insert[original](this[0]);\n        ret = this;\n      } else {\n        for (i = 0, l = insert.length; i < l; i++) {\n          cloneIndex = i;\n          elems = (i > 0 ? this.clone(true) : this).get();\n          jQuery.fn[original].apply(jQuery(insert[i]), elems);\n          ret = ret.concat(elems);\n        }\n        cloneIndex = 0;\n        ret = this.pushStack(ret, name, insert.selector);\n      }\n      tmplItems = appendToTmplItems;\n      appendToTmplItems = null;\n      jQuery.tmpl.complete(tmplItems);\n      return ret;\n    };\n  });\n  jQuery.fn.extend({\n    // Use first wrapped element as template markup.\n    // Return wrapped set of template items, obtained by rendering template against data.\n    tmpl: function tmpl(data, options, parentItem) {\n      return jQuery.tmpl(this[0], data, options, parentItem);\n    },\n    // Find which rendered template item the first wrapped DOM element belongs to\n    tmplItem: function tmplItem() {\n      return jQuery.tmplItem(this[0]);\n    },\n    // Consider the first wrapped element as a template declaration, and get the compiled template or store it as a named template.\n    template: function template(name) {\n      return jQuery.template(name, this[0]);\n    },\n    domManip: function domManip(args, table, callback, options) {\n      // This appears to be a bug in the appendTo, etc. implementation\n      // it should be doing .call() instead of .apply(). See #6227\n      if (args[0] && args[0].nodeType) {\n        var dmArgs = jQuery.makeArray(arguments),\n          argsLength = args.length,\n          i = 0,\n          tmplItem;\n        while (i < argsLength && !(tmplItem = jQuery.data(args[i++], \"tmplItem\"))) {}\n        if (argsLength > 1) {\n          dmArgs[0] = [jQuery.makeArray(args)];\n        }\n        if (tmplItem && cloneIndex) {\n          dmArgs[2] = function (fragClone) {\n            // Handler called by oldManip when rendered template has been inserted into DOM.\n            jQuery.tmpl.afterManip(this, fragClone, callback);\n          };\n        }\n        oldManip.apply(this, dmArgs);\n      } else {\n        oldManip.apply(this, arguments);\n      }\n      cloneIndex = 0;\n      if (!appendToTmplItems) {\n        jQuery.tmpl.complete(newTmplItems);\n      }\n      return this;\n    }\n  });\n  jQuery.extend({\n    // Return wrapped set of template items, obtained by rendering template against data.\n    tmpl: function tmpl(_tmpl, data, options, parentItem) {\n      var ret,\n        topLevel = !parentItem;\n      if (topLevel) {\n        // This is a top-level tmpl call (not from a nested template using {{tmpl}})\n        parentItem = topTmplItem;\n        _tmpl = jQuery.template[_tmpl] || jQuery.template(null, _tmpl);\n        wrappedItems = {}; // Any wrapped items will be rebuilt, since this is top level\n      } else if (!_tmpl) {\n        // The template item is already associated with DOM - this is a refresh.\n        // Re-evaluate rendered template for the parentItem\n        _tmpl = parentItem.tmpl;\n        newTmplItems[parentItem.key] = parentItem;\n        parentItem.nodes = [];\n        if (parentItem.wrapped) {\n          updateWrapped(parentItem, parentItem.wrapped);\n        }\n        // Rebuild, without creating a new template item\n        return jQuery(build(parentItem, null, parentItem.tmpl(jQuery, parentItem)));\n      }\n      if (!_tmpl) {\n        return []; // Could throw...\n      }\n\n      if (typeof data === \"function\") {\n        data = data.call(parentItem || {});\n      }\n      if (options && options.wrapped) {\n        updateWrapped(options, options.wrapped);\n      }\n      ret = jQuery.isArray(data) ? jQuery.map(data, function (dataItem) {\n        return dataItem ? newTmplItem(options, parentItem, _tmpl, dataItem) : null;\n      }) : [newTmplItem(options, parentItem, _tmpl, data)];\n      return topLevel ? jQuery(build(parentItem, null, ret)) : ret;\n    },\n    // Return rendered template item for an element.\n    tmplItem: function tmplItem(elem) {\n      var tmplItem;\n      if (elem instanceof jQuery) {\n        elem = elem[0];\n      }\n      while (elem && elem.nodeType === 1 && !(tmplItem = jQuery.data(elem, \"tmplItem\")) && (elem = elem.parentNode)) {}\n      return tmplItem || topTmplItem;\n    },\n    // Set:\n    // Use $.template( name, tmpl ) to cache a named template,\n    // where tmpl is a template string, a script element or a jQuery instance wrapping a script element, etc.\n    // Use $( \"selector\" ).template( name ) to provide access by name to a script block template declaration.\n\n    // Get:\n    // Use $.template( name ) to access a cached template.\n    // Also $( selectorToScriptBlock ).template(), or $.template( null, templateString )\n    // will return the compiled template, without adding a name reference.\n    // If templateString includes at least one HTML tag, $.template( templateString ) is equivalent\n    // to $.template( null, templateString )\n    template: function template(name, tmpl) {\n      if (tmpl) {\n        // Compile template and associate with name\n        if (typeof tmpl === \"string\") {\n          // This is an HTML string being passed directly in.\n          tmpl = buildTmplFn(tmpl);\n        } else if (tmpl instanceof jQuery) {\n          tmpl = tmpl[0] || {};\n        }\n        if (tmpl.nodeType) {\n          // If this is a template block, use cached copy, or generate tmpl function and cache.\n          tmpl = jQuery.data(tmpl, \"tmpl\") || jQuery.data(tmpl, \"tmpl\", buildTmplFn(tmpl.innerHTML));\n        }\n        return typeof name === \"string\" ? jQuery.template[name] = tmpl : tmpl;\n      }\n      // Return named compiled template\n      return name ? typeof name !== \"string\" ? jQuery.template(null, name) : jQuery.template[name] ||\n      // If not in map, treat as a selector. (If integrated with core, use quickExpr.exec)\n      jQuery.template(null, htmlExpr.test(name) ? name : jQuery(name)) : null;\n    },\n    encode: function encode(text) {\n      // Do HTML encoding replacing < > & and ' and \" by corresponding entities.\n      return (\"\" + text).split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\").split('\"').join(\"&#34;\").split(\"'\").join(\"&#39;\");\n    }\n  });\n  jQuery.extend(jQuery.tmpl, {\n    tag: {\n      \"tmpl\": {\n        _default: {\n          $2: \"null\"\n        },\n        open: \"if($notnull_1){_=_.concat($item.nest($1,$2));}\"\n        // tmpl target parameter can be of type function, so use $1, not $1a (so not auto detection of functions)\n        // This means that {{tmpl foo}} treats foo as a template (which IS a function).\n        // Explicit parens can be used if foo is a function that returns a template: {{tmpl foo()}}.\n      },\n\n      \"wrap\": {\n        _default: {\n          $2: \"null\"\n        },\n        open: \"$item.calls(_,$1,$2);_=[];\",\n        close: \"call=$item.calls();_=call._.concat($item.wrap(call,_));\"\n      },\n      \"each\": {\n        _default: {\n          $2: \"$index, $value\"\n        },\n        open: \"if($notnull_1){$.each($1a,function($2){with(this){\",\n        close: \"}});}\"\n      },\n      \"if\": {\n        open: \"if(($notnull_1) && $1a){\",\n        close: \"}\"\n      },\n      \"else\": {\n        _default: {\n          $1: \"true\"\n        },\n        open: \"}else if(($notnull_1) && $1a){\"\n      },\n      \"html\": {\n        // Unecoded expression evaluation.\n        open: \"if($notnull_1){_.push($1a);}\"\n      },\n      \"=\": {\n        // Encoded expression evaluation. Abbreviated form is ${}.\n        _default: {\n          $1: \"$data\"\n        },\n        open: \"if($notnull_1){_.push($.encode($1a));}\"\n      },\n      \"!\": {\n        // Comment tag. Skipped by parser\n        open: \"\"\n      }\n    },\n    // This stub can be overridden, e.g. in jquery.tmplPlus for providing rendered events\n    complete: function complete(items) {\n      newTmplItems = {};\n    },\n    // Call this from code which overrides domManip, or equivalent\n    // Manage cloning/storing template items etc.\n    afterManip: function afterManip(elem, fragClone, callback) {\n      // Provides cloned fragment ready for fixup prior to and after insertion into DOM\n      var content = fragClone.nodeType === 11 ? jQuery.makeArray(fragClone.childNodes) : fragClone.nodeType === 1 ? [fragClone] : [];\n\n      // Return fragment to original caller (e.g. append) for DOM insertion\n      callback.call(elem, fragClone);\n\n      // Fragment has been inserted:- Add inserted nodes to tmplItem data structure. Replace inserted element annotations by jQuery.data.\n      storeTmplItems(content);\n      cloneIndex++;\n    }\n  });\n\n  //========================== Private helper functions, used by code above ==========================\n\n  function build(tmplItem, nested, content) {\n    // Convert hierarchical content into flat string array\n    // and finally return array of fragments ready for DOM insertion\n    var frag,\n      ret = content ? jQuery.map(content, function (item) {\n        return typeof item === \"string\" ?\n        // Insert template item annotations, to be converted to jQuery.data( \"tmplItem\" ) when elems are inserted into DOM.\n        tmplItem.key ? item.replace(/(<\\w+)(?=[\\s>])(?![^>]*_tmplitem)([^>]*)/g, \"$1 \" + tmplItmAtt + \"=\\\"\" + tmplItem.key + \"\\\" $2\") : item :\n        // This is a child template item. Build nested template.\n        build(item, tmplItem, item._ctnt);\n      }) :\n      // If content is not defined, insert tmplItem directly. Not a template item. May be a string, or a string array, e.g. from {{html $item.html()}}.\n      tmplItem;\n    if (nested) {\n      return ret;\n    }\n\n    // top-level template\n    ret = ret.join(\"\");\n\n    // Support templates which have initial or final text nodes, or consist only of text\n    // Also support HTML entities within the HTML markup.\n    ret.replace(/^\\s*([^<\\s][^<]*)?(<[\\w\\W]+>)([^>]*[^>\\s])?\\s*$/, function (all, before, middle, after) {\n      frag = jQuery(middle).get();\n      storeTmplItems(frag);\n      if (before) {\n        frag = unencode(before).concat(frag);\n      }\n      if (after) {\n        frag = frag.concat(unencode(after));\n      }\n    });\n    return frag ? frag : unencode(ret);\n  }\n  function unencode(text) {\n    // Use createElement, since createTextNode will not render HTML entities correctly\n    var el = document.createElement(\"div\");\n    el.innerHTML = text;\n    return jQuery.makeArray(el.childNodes);\n  }\n\n  // Generate a reusable function that will serve to render a template against data\n  function buildTmplFn(markup) {\n    return new Function(\"jQuery\", \"$item\", \"var $=jQuery,call,_=[],$data=$item.data;\" +\n    // Introduce the data as local variables using with(){}\n    \"with($data){_.push('\" +\n    // Convert the template into pure JavaScript\n    jQuery.trim(markup).replace(/([\\\\'])/g, \"\\\\$1\").replace(/[\\r\\t\\n]/g, \" \").replace(/\\$\\{([^\\}]*)\\}/g, \"{{= $1}}\").replace(/\\{\\{(\\/?)(\\w+|.)(?:\\(((?:[^\\}]|\\}(?!\\}))*?)?\\))?(?:\\s+(.*?)?)?(\\(((?:[^\\}]|\\}(?!\\}))*?)\\))?\\s*\\}\\}/g, function (all, slash, type, fnargs, target, parens, args) {\n      var tag = jQuery.tmpl.tag[type],\n        def,\n        expr,\n        exprAutoFnDetect;\n      if (!tag) {\n        throw \"Template command not found: \" + type;\n      }\n      def = tag._default || [];\n      if (parens && !/\\w$/.test(target)) {\n        target += parens;\n        parens = \"\";\n      }\n      if (target) {\n        target = unescape(target);\n        args = args ? \",\" + unescape(args) + \")\" : parens ? \")\" : \"\";\n        // Support for target being things like a.toLowerCase();\n        // In that case don't call with template item as 'this' pointer. Just evaluate...\n        expr = parens ? target.indexOf(\".\") > -1 ? target + parens : \"(\" + target + \").call($item\" + args : target;\n        exprAutoFnDetect = parens ? expr : \"(typeof(\" + target + \")==='function'?(\" + target + \").call($item):(\" + target + \"))\";\n      } else {\n        exprAutoFnDetect = expr = def.$1 || \"null\";\n      }\n      fnargs = unescape(fnargs);\n      return \"');\" + tag[slash ? \"close\" : \"open\"].split(\"$notnull_1\").join(target ? \"typeof(\" + target + \")!=='undefined' && (\" + target + \")!=null\" : \"true\").split(\"$1a\").join(exprAutoFnDetect).split(\"$1\").join(expr).split(\"$2\").join(fnargs ? fnargs.replace(/\\s*([^\\(]+)\\s*(\\((.*?)\\))?/g, function (all, name, parens, params) {\n        params = params ? \",\" + params + \")\" : parens ? \")\" : \"\";\n        return params ? \"(\" + name + \").call($item\" + params : all;\n      }) : def.$2 || \"\") + \"_.push('\";\n    }) + \"');}return _;\");\n  }\n  function updateWrapped(options, wrapped) {\n    // Build the wrapped content.\n    options._wrap = build(options, true,\n    // Suport imperative scenario in which options.wrapped can be set to a selector or an HTML string.\n    jQuery.isArray(wrapped) ? wrapped : [htmlExpr.test(wrapped) ? wrapped : jQuery(wrapped).html()]).join(\"\");\n  }\n  function unescape(args) {\n    return args ? args.replace(/\\\\'/g, \"'\").replace(/\\\\\\\\/g, \"\\\\\") : null;\n  }\n  function outerHtml(elem) {\n    var div = document.createElement(\"div\");\n    div.appendChild(elem.cloneNode(true));\n    return div.innerHTML;\n  }\n\n  // Store template items in jQuery.data(), ensuring a unique tmplItem data data structure for each rendered template instance.\n  function storeTmplItems(content) {\n    var keySuffix = \"_\" + cloneIndex,\n      elem,\n      elems,\n      newClonedItems = {},\n      i,\n      l,\n      m;\n    for (i = 0, l = content.length; i < l; i++) {\n      if ((elem = content[i]).nodeType !== 1) {\n        continue;\n      }\n      elems = elem.getElementsByTagName(\"*\");\n      for (m = elems.length - 1; m >= 0; m--) {\n        processItemKey(elems[m]);\n      }\n      processItemKey(elem);\n    }\n    function processItemKey(el) {\n      var pntKey,\n        pntNode = el,\n        pntItem,\n        tmplItem,\n        key;\n      // Ensure that each rendered template inserted into the DOM has its own template item,\n      if (key = el.getAttribute(tmplItmAtt)) {\n        while (pntNode.parentNode && (pntNode = pntNode.parentNode).nodeType === 1 && !(pntKey = pntNode.getAttribute(tmplItmAtt))) {}\n        if (pntKey !== key) {\n          // The next ancestor with a _tmplitem expando is on a different key than this one.\n          // So this is a top-level element within this template item\n          // Set pntNode to the key of the parentNode, or to 0 if pntNode.parentNode is null, or pntNode is a fragment.\n          pntNode = pntNode.parentNode ? pntNode.nodeType === 11 ? 0 : pntNode.getAttribute(tmplItmAtt) || 0 : 0;\n          if (!(tmplItem = newTmplItems[key])) {\n            // The item is for wrapped content, and was copied from the temporary parent wrappedItem.\n            tmplItem = wrappedItems[key];\n            tmplItem = newTmplItem(tmplItem, newTmplItems[pntNode] || wrappedItems[pntNode], null, true);\n            tmplItem.key = ++itemKey;\n            newTmplItems[itemKey] = tmplItem;\n          }\n          if (cloneIndex) {\n            cloneTmplItem(key);\n          }\n        }\n        el.removeAttribute(tmplItmAtt);\n      } else if (cloneIndex && (tmplItem = jQuery.data(el, \"tmplItem\"))) {\n        // This was a rendered element, cloned during append or appendTo etc.\n        // TmplItem stored in jQuery data has already been cloned in cloneCopyEvent. We must replace it with a fresh cloned tmplItem.\n        cloneTmplItem(tmplItem.key);\n        newTmplItems[tmplItem.key] = tmplItem;\n        pntNode = jQuery.data(el.parentNode, \"tmplItem\");\n        pntNode = pntNode ? pntNode.key : 0;\n      }\n      if (tmplItem) {\n        pntItem = tmplItem;\n        // Find the template item of the parent element.\n        // (Using !=, not !==, since pntItem.key is number, and pntNode may be a string)\n        while (pntItem && pntItem.key != pntNode) {\n          // Add this element as a top-level node for this rendered template item, as well as for any\n          // ancestor items between this item and the item of its parent element\n          pntItem.nodes.push(el);\n          pntItem = pntItem.parent;\n        }\n        // Delete content built during rendering - reduce API surface area and memory use, and avoid exposing of stale data after rendering...\n        delete tmplItem._ctnt;\n        delete tmplItem._wrap;\n        // Store template item as jQuery data on the element\n        jQuery.data(el, \"tmplItem\", tmplItem);\n      }\n      function cloneTmplItem(key) {\n        key = key + keySuffix;\n        tmplItem = newClonedItems[key] = newClonedItems[key] || newTmplItem(tmplItem, newTmplItems[tmplItem.parent.key + keySuffix] || tmplItem.parent, null, true);\n      }\n    }\n  }\n\n  //---- Helper functions for template item ----\n\n  function tiCalls(content, tmpl, data, options) {\n    if (!content) {\n      return stack.pop();\n    }\n    stack.push({\n      _: content,\n      tmpl: tmpl,\n      item: this,\n      data: data,\n      options: options\n    });\n  }\n  function tiNest(tmpl, data, options) {\n    // nested template, using {{tmpl}} tag\n    return jQuery.tmpl(jQuery.template(tmpl), data, options, this);\n  }\n  function tiWrap(call, wrapped) {\n    // nested template, using {{wrap}} tag\n    var options = call.options || {};\n    options.wrapped = wrapped;\n    // Apply the template, which may incorporate wrapped content,\n    return jQuery.tmpl(jQuery.template(call.tmpl), call.data, options, call.item);\n  }\n  function tiHtml(filter, textOnly) {\n    var wrapped = this._wrap;\n    return jQuery.map(jQuery(jQuery.isArray(wrapped) ? wrapped.join(\"\") : wrapped).filter(filter || \"*\"), function (e) {\n      return textOnly ? e.innerText || e.textContent : e.outerHTML || outerHtml(e);\n    });\n  }\n  function tiUpdate() {\n    var coll = this.nodes;\n    jQuery.tmpl(null, null, null, this).insertBefore(coll[0]);\n    jQuery(coll).remove();\n  }\n})(jQuery);","map":{"version":3,"mappings":"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","names":["jQuery","undefined","oldManip","fn","domManip","tmplItmAtt","htmlExpr","newTmplItems","wrappedItems","appendToTmplItems","topTmplItem","key","data","itemKey","cloneIndex","stack","newTmplItem","options","parentItem","newItem","_wrap","tmpl","parent","nodes","calls","tiCalls","nest","tiNest","wrap","tiWrap","html","tiHtml","update","tiUpdate","extend","_ctnt","length","each","appendTo","prependTo","insertBefore","insertAfter","replaceAll","name","original","selector","ret","insert","elems","i","l","tmplItems","parentNode","nodeType","childNodes","clone","get","apply","concat","pushStack","complete","tmplItem","template","args","table","callback","dmArgs","makeArray","arguments","argsLength","fragClone","afterManip","topLevel","wrapped","updateWrapped","build","call","isArray","map","dataItem","elem","buildTmplFn","innerHTML","test","encode","text","split","join","tag","_default","$2","open","close","$1","items","content","storeTmplItems","nested","frag","item","replace","all","before","middle","after","unencode","el","document","createElement","markup","Function","trim","slash","type","fnargs","target","parens","def","expr","exprAutoFnDetect","unescape","indexOf","params","outerHtml","div","appendChild","cloneNode","keySuffix","newClonedItems","m","getElementsByTagName","processItemKey","pntKey","pntNode","pntItem","getAttribute","cloneTmplItem","removeAttribute","push","pop","_","filter","textOnly","e","innerText","textContent","outerHTML","coll","remove"],"sources":["/home/alan/.rvm/gems/ruby-3.0.3/gems/decidim-core-0.27.0/app/packs/src/decidim/vendor/jquery-tmpl.js"],"sourcesContent":["/* eslint-disable */\n\n/*\n * jQuery Templating Plugin\n * Copyright 2010, John Resig\n * Dual licensed under the MIT or GPL Version 2 licenses.\n */\n;(function( jQuery, undefined ){\n    var oldManip = jQuery.fn.domManip, tmplItmAtt = \"_tmplitem\", htmlExpr = /^[^<]*(<[\\w\\W]+>)[^>]*$|\\{\\{\\! /,\n        newTmplItems = {}, wrappedItems = {}, appendToTmplItems, topTmplItem = { key: 0, data: {} }, itemKey = 0, cloneIndex = 0, stack = [];\n\n    function newTmplItem( options, parentItem, fn, data ) {\n        // Returns a template item data structure for a new rendered instance of a template (a 'template item').\n        // The content field is a hierarchical array of strings and nested items (to be\n        // removed and replaced by nodes field of dom elements, once inserted in DOM).\n        var newItem = {\n            data: data || (parentItem ? parentItem.data : {}),\n            _wrap: parentItem ? parentItem._wrap : null,\n            tmpl: null,\n            parent: parentItem || null,\n            nodes: [],\n            calls: tiCalls,\n            nest: tiNest,\n            wrap: tiWrap,\n            html: tiHtml,\n            update: tiUpdate\n        };\n        if ( options ) {\n            jQuery.extend( newItem, options, { nodes: [], parent: parentItem } );\n        }\n        if ( fn ) {\n            // Build the hierarchical content to be used during insertion into DOM\n            newItem.tmpl = fn;\n            newItem._ctnt = newItem._ctnt || newItem.tmpl( jQuery, newItem );\n            newItem.key = ++itemKey;\n            // Keep track of new template item, until it is stored as jQuery Data on DOM element\n            (stack.length ? wrappedItems : newTmplItems)[itemKey] = newItem;\n        }\n        return newItem;\n    }\n\n    // Override appendTo etc., in order to provide support for targeting multiple elements. (This code would disappear if integrated in jquery core).\n    jQuery.each({\n        appendTo: \"append\",\n        prependTo: \"prepend\",\n        insertBefore: \"before\",\n        insertAfter: \"after\",\n        replaceAll: \"replaceWith\"\n    }, function( name, original ) {\n        jQuery.fn[ name ] = function( selector ) {\n            var ret = [], insert = jQuery( selector ), elems, i, l, tmplItems,\n                parent = this.length === 1 && this[0].parentNode;\n\n            appendToTmplItems = newTmplItems || {};\n            if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {\n                insert[ original ]( this[0] );\n                ret = this;\n            } else {\n                for ( i = 0, l = insert.length; i < l; i++ ) {\n                    cloneIndex = i;\n                    elems = (i > 0 ? this.clone(true) : this).get();\n                    jQuery.fn[ original ].apply( jQuery(insert[i]), elems );\n                    ret = ret.concat( elems );\n                }\n                cloneIndex = 0;\n                ret = this.pushStack( ret, name, insert.selector );\n            }\n            tmplItems = appendToTmplItems;\n            appendToTmplItems = null;\n            jQuery.tmpl.complete( tmplItems );\n            return ret;\n        };\n    });\n\n    jQuery.fn.extend({\n        // Use first wrapped element as template markup.\n        // Return wrapped set of template items, obtained by rendering template against data.\n        tmpl: function( data, options, parentItem ) {\n            return jQuery.tmpl( this[0], data, options, parentItem );\n        },\n\n        // Find which rendered template item the first wrapped DOM element belongs to\n        tmplItem: function() {\n            return jQuery.tmplItem( this[0] );\n        },\n\n        // Consider the first wrapped element as a template declaration, and get the compiled template or store it as a named template.\n        template: function( name ) {\n            return jQuery.template( name, this[0] );\n        },\n\n        domManip: function( args, table, callback, options ) {\n            // This appears to be a bug in the appendTo, etc. implementation\n            // it should be doing .call() instead of .apply(). See #6227\n            if ( args[0] && args[0].nodeType ) {\n                var dmArgs = jQuery.makeArray( arguments ), argsLength = args.length, i = 0, tmplItem;\n                while ( i < argsLength && !(tmplItem = jQuery.data( args[i++], \"tmplItem\" ))) {}\n                if ( argsLength > 1 ) {\n                    dmArgs[0] = [jQuery.makeArray( args )];\n                }\n                if ( tmplItem && cloneIndex ) {\n                    dmArgs[2] = function( fragClone ) {\n                        // Handler called by oldManip when rendered template has been inserted into DOM.\n                        jQuery.tmpl.afterManip( this, fragClone, callback );\n                    };\n                }\n                oldManip.apply( this, dmArgs );\n            } else {\n                oldManip.apply( this, arguments );\n            }\n            cloneIndex = 0;\n            if ( !appendToTmplItems ) {\n                jQuery.tmpl.complete( newTmplItems );\n            }\n            return this;\n        }\n    });\n\n    jQuery.extend({\n        // Return wrapped set of template items, obtained by rendering template against data.\n        tmpl: function( tmpl, data, options, parentItem ) {\n            var ret, topLevel = !parentItem;\n            if ( topLevel ) {\n                // This is a top-level tmpl call (not from a nested template using {{tmpl}})\n                parentItem = topTmplItem;\n                tmpl = jQuery.template[tmpl] || jQuery.template( null, tmpl );\n                wrappedItems = {}; // Any wrapped items will be rebuilt, since this is top level\n            } else if ( !tmpl ) {\n                // The template item is already associated with DOM - this is a refresh.\n                // Re-evaluate rendered template for the parentItem\n                tmpl = parentItem.tmpl;\n                newTmplItems[parentItem.key] = parentItem;\n                parentItem.nodes = [];\n                if ( parentItem.wrapped ) {\n                    updateWrapped( parentItem, parentItem.wrapped );\n                }\n                // Rebuild, without creating a new template item\n                return jQuery( build( parentItem, null, parentItem.tmpl( jQuery, parentItem ) ));\n            }\n            if ( !tmpl ) {\n                return []; // Could throw...\n            }\n            if ( typeof data === \"function\" ) {\n                data = data.call( parentItem || {} );\n            }\n            if ( options && options.wrapped ) {\n                updateWrapped( options, options.wrapped );\n            }\n            ret = jQuery.isArray( data ) ?\n                jQuery.map( data, function( dataItem ) {\n                    return dataItem ? newTmplItem( options, parentItem, tmpl, dataItem ) : null;\n                }) :\n                [ newTmplItem( options, parentItem, tmpl, data ) ];\n            return topLevel ? jQuery( build( parentItem, null, ret ) ) : ret;\n        },\n\n        // Return rendered template item for an element.\n        tmplItem: function( elem ) {\n            var tmplItem;\n            if ( elem instanceof jQuery ) {\n                elem = elem[0];\n            }\n            while ( elem && elem.nodeType === 1 && !(tmplItem = jQuery.data( elem, \"tmplItem\" )) && (elem = elem.parentNode) ) {}\n            return tmplItem || topTmplItem;\n        },\n\n        // Set:\n        // Use $.template( name, tmpl ) to cache a named template,\n        // where tmpl is a template string, a script element or a jQuery instance wrapping a script element, etc.\n        // Use $( \"selector\" ).template( name ) to provide access by name to a script block template declaration.\n\n        // Get:\n        // Use $.template( name ) to access a cached template.\n        // Also $( selectorToScriptBlock ).template(), or $.template( null, templateString )\n        // will return the compiled template, without adding a name reference.\n        // If templateString includes at least one HTML tag, $.template( templateString ) is equivalent\n        // to $.template( null, templateString )\n        template: function( name, tmpl ) {\n            if (tmpl) {\n                // Compile template and associate with name\n                if ( typeof tmpl === \"string\" ) {\n                    // This is an HTML string being passed directly in.\n                    tmpl = buildTmplFn( tmpl )\n                } else if ( tmpl instanceof jQuery ) {\n                    tmpl = tmpl[0] || {};\n                }\n                if ( tmpl.nodeType ) {\n                    // If this is a template block, use cached copy, or generate tmpl function and cache.\n                    tmpl = jQuery.data( tmpl, \"tmpl\" ) || jQuery.data( tmpl, \"tmpl\", buildTmplFn( tmpl.innerHTML ));\n                }\n                return typeof name === \"string\" ? (jQuery.template[name] = tmpl) : tmpl;\n            }\n            // Return named compiled template\n            return name ? (typeof name !== \"string\" ? jQuery.template( null, name ):\n                (jQuery.template[name] ||\n                    // If not in map, treat as a selector. (If integrated with core, use quickExpr.exec)\n                    jQuery.template( null, htmlExpr.test( name ) ? name : jQuery( name )))) : null;\n        },\n\n        encode: function( text ) {\n            // Do HTML encoding replacing < > & and ' and \" by corresponding entities.\n            return (\"\" + text).split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\").split('\"').join(\"&#34;\").split(\"'\").join(\"&#39;\");\n        }\n    });\n\n    jQuery.extend( jQuery.tmpl, {\n        tag: {\n            \"tmpl\": {\n                _default: { $2: \"null\" },\n                open: \"if($notnull_1){_=_.concat($item.nest($1,$2));}\"\n                // tmpl target parameter can be of type function, so use $1, not $1a (so not auto detection of functions)\n                // This means that {{tmpl foo}} treats foo as a template (which IS a function).\n                // Explicit parens can be used if foo is a function that returns a template: {{tmpl foo()}}.\n            },\n            \"wrap\": {\n                _default: { $2: \"null\" },\n                open: \"$item.calls(_,$1,$2);_=[];\",\n                close: \"call=$item.calls();_=call._.concat($item.wrap(call,_));\"\n            },\n            \"each\": {\n                _default: { $2: \"$index, $value\" },\n                open: \"if($notnull_1){$.each($1a,function($2){with(this){\",\n                close: \"}});}\"\n            },\n            \"if\": {\n                open: \"if(($notnull_1) && $1a){\",\n                close: \"}\"\n            },\n            \"else\": {\n                _default: { $1: \"true\" },\n                open: \"}else if(($notnull_1) && $1a){\"\n            },\n            \"html\": {\n                // Unecoded expression evaluation.\n                open: \"if($notnull_1){_.push($1a);}\"\n            },\n            \"=\": {\n                // Encoded expression evaluation. Abbreviated form is ${}.\n                _default: { $1: \"$data\" },\n                open: \"if($notnull_1){_.push($.encode($1a));}\"\n            },\n            \"!\": {\n                // Comment tag. Skipped by parser\n                open: \"\"\n            }\n        },\n\n        // This stub can be overridden, e.g. in jquery.tmplPlus for providing rendered events\n        complete: function( items ) {\n            newTmplItems = {};\n        },\n\n        // Call this from code which overrides domManip, or equivalent\n        // Manage cloning/storing template items etc.\n        afterManip: function afterManip( elem, fragClone, callback ) {\n            // Provides cloned fragment ready for fixup prior to and after insertion into DOM\n            var content = fragClone.nodeType === 11 ?\n                jQuery.makeArray(fragClone.childNodes) :\n                fragClone.nodeType === 1 ? [fragClone] : [];\n\n            // Return fragment to original caller (e.g. append) for DOM insertion\n            callback.call( elem, fragClone );\n\n            // Fragment has been inserted:- Add inserted nodes to tmplItem data structure. Replace inserted element annotations by jQuery.data.\n            storeTmplItems( content );\n            cloneIndex++;\n        }\n    });\n\n    //========================== Private helper functions, used by code above ==========================\n\n    function build( tmplItem, nested, content ) {\n        // Convert hierarchical content into flat string array\n        // and finally return array of fragments ready for DOM insertion\n        var frag, ret = content ? jQuery.map( content, function( item ) {\n            return (typeof item === \"string\") ?\n                // Insert template item annotations, to be converted to jQuery.data( \"tmplItem\" ) when elems are inserted into DOM.\n                (tmplItem.key ? item.replace( /(<\\w+)(?=[\\s>])(?![^>]*_tmplitem)([^>]*)/g, \"$1 \" + tmplItmAtt + \"=\\\"\" + tmplItem.key + \"\\\" $2\" ) : item) :\n                // This is a child template item. Build nested template.\n                build( item, tmplItem, item._ctnt );\n        }) :\n        // If content is not defined, insert tmplItem directly. Not a template item. May be a string, or a string array, e.g. from {{html $item.html()}}.\n        tmplItem;\n        if ( nested ) {\n            return ret;\n        }\n\n        // top-level template\n        ret = ret.join(\"\");\n\n        // Support templates which have initial or final text nodes, or consist only of text\n        // Also support HTML entities within the HTML markup.\n        ret.replace( /^\\s*([^<\\s][^<]*)?(<[\\w\\W]+>)([^>]*[^>\\s])?\\s*$/, function( all, before, middle, after) {\n            frag = jQuery( middle ).get();\n\n            storeTmplItems( frag );\n            if ( before ) {\n                frag = unencode( before ).concat(frag);\n            }\n            if ( after ) {\n                frag = frag.concat(unencode( after ));\n            }\n        });\n        return frag ? frag : unencode( ret );\n    }\n\n    function unencode( text ) {\n        // Use createElement, since createTextNode will not render HTML entities correctly\n        var el = document.createElement( \"div\" );\n        el.innerHTML = text;\n        return jQuery.makeArray(el.childNodes);\n    }\n\n    // Generate a reusable function that will serve to render a template against data\n    function buildTmplFn( markup ) {\n        return new Function(\"jQuery\",\"$item\",\n            \"var $=jQuery,call,_=[],$data=$item.data;\" +\n\n            // Introduce the data as local variables using with(){}\n            \"with($data){_.push('\" +\n\n            // Convert the template into pure JavaScript\n            jQuery.trim(markup)\n                .replace( /([\\\\'])/g, \"\\\\$1\" )\n                .replace( /[\\r\\t\\n]/g, \" \" )\n                .replace( /\\$\\{([^\\}]*)\\}/g, \"{{= $1}}\" )\n                .replace( /\\{\\{(\\/?)(\\w+|.)(?:\\(((?:[^\\}]|\\}(?!\\}))*?)?\\))?(?:\\s+(.*?)?)?(\\(((?:[^\\}]|\\}(?!\\}))*?)\\))?\\s*\\}\\}/g,\n                function( all, slash, type, fnargs, target, parens, args ) {\n                    var tag = jQuery.tmpl.tag[ type ], def, expr, exprAutoFnDetect;\n                    if ( !tag ) {\n                        throw \"Template command not found: \" + type;\n                    }\n                    def = tag._default || [];\n                    if ( parens && !/\\w$/.test(target)) {\n                        target += parens;\n                        parens = \"\";\n                    }\n                    if ( target ) {\n                        target = unescape( target );\n                        args = args ? (\",\" + unescape( args ) + \")\") : (parens ? \")\" : \"\");\n                        // Support for target being things like a.toLowerCase();\n                        // In that case don't call with template item as 'this' pointer. Just evaluate...\n                        expr = parens ? (target.indexOf(\".\") > -1 ? target + parens : (\"(\" + target + \").call($item\" + args)) : target;\n                        exprAutoFnDetect = parens ? expr : \"(typeof(\" + target + \")==='function'?(\" + target + \").call($item):(\" + target + \"))\";\n                    } else {\n                        exprAutoFnDetect = expr = def.$1 || \"null\";\n                    }\n                    fnargs = unescape( fnargs );\n                    return \"');\" +\n                        tag[ slash ? \"close\" : \"open\" ]\n                            .split( \"$notnull_1\" ).join( target ? \"typeof(\" + target + \")!=='undefined' && (\" + target + \")!=null\" : \"true\" )\n                            .split( \"$1a\" ).join( exprAutoFnDetect )\n                            .split( \"$1\" ).join( expr )\n                            .split( \"$2\" ).join( fnargs ?\n                                fnargs.replace( /\\s*([^\\(]+)\\s*(\\((.*?)\\))?/g, function( all, name, parens, params ) {\n                                    params = params ? (\",\" + params + \")\") : (parens ? \")\" : \"\");\n                                    return params ? (\"(\" + name + \").call($item\" + params) : all;\n                                })\n                                : (def.$2||\"\")\n                            ) +\n                        \"_.push('\";\n                }) +\n            \"');}return _;\"\n        );\n    }\n    function updateWrapped( options, wrapped ) {\n        // Build the wrapped content.\n        options._wrap = build( options, true,\n            // Suport imperative scenario in which options.wrapped can be set to a selector or an HTML string.\n            jQuery.isArray( wrapped ) ? wrapped : [htmlExpr.test( wrapped ) ? wrapped : jQuery( wrapped ).html()]\n        ).join(\"\");\n    }\n\n    function unescape( args ) {\n        return args ? args.replace( /\\\\'/g, \"'\").replace(/\\\\\\\\/g, \"\\\\\" ) : null;\n    }\n    function outerHtml( elem ) {\n        var div = document.createElement(\"div\");\n        div.appendChild( elem.cloneNode(true) );\n        return div.innerHTML;\n    }\n\n    // Store template items in jQuery.data(), ensuring a unique tmplItem data data structure for each rendered template instance.\n    function storeTmplItems( content ) {\n        var keySuffix = \"_\" + cloneIndex, elem, elems, newClonedItems = {}, i, l, m;\n        for ( i = 0, l = content.length; i < l; i++ ) {\n            if ( (elem = content[i]).nodeType !== 1 ) {\n                continue;\n            }\n            elems = elem.getElementsByTagName(\"*\");\n            for ( m = elems.length - 1; m >= 0; m-- ) {\n                processItemKey( elems[m] );\n            }\n            processItemKey( elem );\n        }\n        function processItemKey( el ) {\n            var pntKey, pntNode = el, pntItem, tmplItem, key;\n            // Ensure that each rendered template inserted into the DOM has its own template item,\n            if ( (key = el.getAttribute( tmplItmAtt ))) {\n                while ( pntNode.parentNode && (pntNode = pntNode.parentNode).nodeType === 1 && !(pntKey = pntNode.getAttribute( tmplItmAtt ))) { }\n                if ( pntKey !== key ) {\n                    // The next ancestor with a _tmplitem expando is on a different key than this one.\n                    // So this is a top-level element within this template item\n                    // Set pntNode to the key of the parentNode, or to 0 if pntNode.parentNode is null, or pntNode is a fragment.\n                    pntNode = pntNode.parentNode ? (pntNode.nodeType === 11 ? 0 : (pntNode.getAttribute( tmplItmAtt ) || 0)) : 0;\n                    if ( !(tmplItem = newTmplItems[key]) ) {\n                        // The item is for wrapped content, and was copied from the temporary parent wrappedItem.\n                        tmplItem = wrappedItems[key];\n                        tmplItem = newTmplItem( tmplItem, newTmplItems[pntNode]||wrappedItems[pntNode], null, true );\n                        tmplItem.key = ++itemKey;\n                        newTmplItems[itemKey] = tmplItem;\n                    }\n                    if ( cloneIndex ) {\n                        cloneTmplItem( key );\n                    }\n                }\n                el.removeAttribute( tmplItmAtt );\n            } else if ( cloneIndex && (tmplItem = jQuery.data( el, \"tmplItem\" )) ) {\n                // This was a rendered element, cloned during append or appendTo etc.\n                // TmplItem stored in jQuery data has already been cloned in cloneCopyEvent. We must replace it with a fresh cloned tmplItem.\n                cloneTmplItem( tmplItem.key );\n                newTmplItems[tmplItem.key] = tmplItem;\n                pntNode = jQuery.data( el.parentNode, \"tmplItem\" );\n                pntNode = pntNode ? pntNode.key : 0;\n            }\n            if ( tmplItem ) {\n                pntItem = tmplItem;\n                // Find the template item of the parent element.\n                // (Using !=, not !==, since pntItem.key is number, and pntNode may be a string)\n                while ( pntItem && pntItem.key != pntNode ) {\n                    // Add this element as a top-level node for this rendered template item, as well as for any\n                    // ancestor items between this item and the item of its parent element\n                    pntItem.nodes.push( el );\n                    pntItem = pntItem.parent;\n                }\n                // Delete content built during rendering - reduce API surface area and memory use, and avoid exposing of stale data after rendering...\n                delete tmplItem._ctnt;\n                delete tmplItem._wrap;\n                // Store template item as jQuery data on the element\n                jQuery.data( el, \"tmplItem\", tmplItem );\n            }\n            function cloneTmplItem( key ) {\n                key = key + keySuffix;\n                tmplItem = newClonedItems[key] =\n                    (newClonedItems[key] || newTmplItem( tmplItem, newTmplItems[tmplItem.parent.key + keySuffix] || tmplItem.parent, null, true ));\n            }\n        }\n    }\n\n    //---- Helper functions for template item ----\n\n    function tiCalls( content, tmpl, data, options ) {\n        if ( !content ) {\n            return stack.pop();\n        }\n        stack.push({ _: content, tmpl: tmpl, item:this, data: data, options: options });\n    }\n\n    function tiNest( tmpl, data, options ) {\n        // nested template, using {{tmpl}} tag\n        return jQuery.tmpl( jQuery.template( tmpl ), data, options, this );\n    }\n\n    function tiWrap( call, wrapped ) {\n        // nested template, using {{wrap}} tag\n        var options = call.options || {};\n        options.wrapped = wrapped;\n        // Apply the template, which may incorporate wrapped content,\n        return jQuery.tmpl( jQuery.template( call.tmpl ), call.data, options, call.item );\n    }\n\n    function tiHtml( filter, textOnly ) {\n        var wrapped = this._wrap;\n        return jQuery.map(\n            jQuery( jQuery.isArray( wrapped ) ? wrapped.join(\"\") : wrapped ).filter( filter || \"*\" ),\n            function(e) {\n                return textOnly ?\n                    e.innerText || e.textContent :\n                    e.outerHTML || outerHtml(e);\n            });\n    }\n\n    function tiUpdate() {\n        var coll = this.nodes;\n        jQuery.tmpl( null, null, null, this).insertBefore( coll[0] );\n        jQuery( coll ).remove();\n    }\n})( jQuery );\n"]},"metadata":{},"sourceType":"module"}