{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n/* eslint-disable require-jsdoc */\n\nvar History = Quill[\"import\"](\"modules/history\");\nHistory.DEFAULTS = {\n  delay: 1000,\n  maxStack: 100,\n  userOnly: true\n};\n\n/**\n * Linebreak module brokes quill's default history class.\n * So here we are moving innerHTML to undo and redo stack\n * instead of deltas.\n */\nvar HistoryOverride = /*#__PURE__*/function (_History) {\n  _inherits(HistoryOverride, _History);\n  var _super = _createSuper(HistoryOverride);\n  function HistoryOverride(quill, options) {\n    var _this;\n    _classCallCheck(this, HistoryOverride);\n    _this = _super.call(this, quill, options);\n    _this.lastRecorded = 0;\n    _this.ignoreChange = false;\n    _this.init = false;\n    _this.quill.emitter.on(\"editor-ready\", function () {\n      _this.clear();\n      var $input = $(_this.quill.container).siblings('input[type=\"hidden\"]');\n      _this.stack.undo.push({\n        content: $input.val() || \"\",\n        index: _this.quill.getLength() - 2\n      });\n      _this.lastLength = _this.quill.getLength();\n    });\n    /* eslint-disable max-params */\n    _this.quill.on(Quill.events.EDITOR_CHANGE, function (eventName, delta, oldDelta, source) {\n      if (!delta) {\n        return;\n      }\n      if (!_this.init && eventName === \"selection-change\") {\n        _this.stack.undo[0].index = delta.index;\n      }\n      if (eventName !== Quill.events.TEXT_CHANGE || _this.ignoreChange) {\n        return;\n      }\n      if (!_this.options.userOnly || source === Quill.sources.USER) {\n        _this.record(delta, oldDelta);\n      }\n    });\n    _this.quill.keyboard.addBinding({\n      key: \"Z\",\n      shortKey: true\n    }, _this.undo.bind(_assertThisInitialized(_this)));\n    _this.quill.keyboard.addBinding({\n      key: \"Z\",\n      shortKey: true,\n      shiftKey: true\n    }, _this.redo.bind(_assertThisInitialized(_this)));\n    if (/Win/i.test(navigator.platform)) {\n      _this.quill.keyboard.addBinding({\n        key: \"Y\",\n        shortKey: true\n      }, _this.redo.bind(_assertThisInitialized(_this)));\n    }\n    return _this;\n  }\n  /* eslint-enable max-params */\n  _createClass(HistoryOverride, [{\n    key: \"change\",\n    value: function change(source, dest) {\n      if (this.stack[source].length === 0) {\n        return;\n      }\n      var obj = this.updateStacks(source, dest);\n      if (!obj.content) {\n        return;\n      }\n      if (!obj.index) {\n        obj.index = 0;\n      }\n      this.lastRecorded = 0;\n      this.ignoreChange = true;\n      this.quill.setContents(this.quill.clipboard.convert(obj.content));\n      this.ignoreChange = false;\n      var index = obj.index;\n      this.quill.setSelection(index);\n    }\n  }, {\n    key: \"updateStacks\",\n    value: function updateStacks(source, dest) {\n      if (source === \"undo\") {\n        if (this.stack.undo.length === 1) {\n          return this.stack.undo[0];\n        }\n        this.stack[dest].push(this.stack.undo.pop());\n        return this.stack.undo[this.stack.undo.length - 1];\n      }\n      var content = this.stack.redo.pop();\n      this.stack.undo.push(content);\n      return content;\n    }\n  }, {\n    key: \"record\",\n    value: function record(changeDelta) {\n      if (changeDelta.ops.length === 0) {\n        return;\n      } else if (!this.init) {\n        this.init = true;\n      }\n      this.stack.redo = [];\n      var timestamp = Date.now();\n      // Should not return after length check, because after linebreak a keypress replaces invisible characters with\n      // visible characters.\n      // For example: <br><br></p> -> [press X] -> <br>X</p>.\n      if (Math.abs(this.lastLength === this.quill.getLength()) || this.lastRecorded + this.options.delay > timestamp) {\n        if (this.stack.undo.length > 1) {\n          this.stack.undo.pop();\n        }\n      } else {\n        this.lastLength = this.quill.getLength();\n        if (this.lastRecorded + this.options.delay <= timestamp) {\n          this.lastRecorded = timestamp;\n        }\n      }\n      this.stack.undo.push({\n        content: this.quill.container.firstChild.innerHTML,\n        index: this.quill.getSelection()\n      });\n    }\n  }, {\n    key: \"transform\",\n    value: function transform() {\n      return;\n    }\n  }]);\n  return HistoryOverride;\n}(History);\nexport { HistoryOverride as default };","map":{"version":3,"mappings":"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","names":["History","Quill","DEFAULTS","delay","maxStack","userOnly","HistoryOverride","_inherits","quill","options","_classCallCheck","_this","lastRecorded","ignoreChange","init","emitter","on","clear","$input","$","container","siblings","stack","undo","push","content","val","index","getLength","lastLength","events","EDITOR_CHANGE","eventName","delta","oldDelta","source","TEXT_CHANGE","sources","USER","record","keyboard","addBinding","key","shortKey","bind","shiftKey","redo","test","navigator","platform","_createClass","value","dest","length","obj","updateStacks","setContents","clipboard","convert","setSelection","pop","changeDelta","ops","timestamp","Date","now","Math","abs","firstChild","innerHTML","getSelection"],"sources":["/home/alan/.rvm/gems/ruby-3.0.3/gems/decidim-core-0.27.0/app/packs/src/decidim/editor/history_override.js"],"sourcesContent":["/* eslint-disable require-jsdoc */\n\nconst History = Quill.import(\"modules/history\");\nHistory.DEFAULTS = {\n  delay: 1000,\n  maxStack: 100,\n  userOnly: true\n};\n\n/**\n * Linebreak module brokes quill's default history class.\n * So here we are moving innerHTML to undo and redo stack\n * instead of deltas.\n */\nexport default class HistoryOverride extends History {\n  constructor(quill, options) {\n    super(quill, options);\n    this.lastRecorded = 0;\n    this.ignoreChange = false;\n    this.init = false;\n    this.quill.emitter.on(\"editor-ready\", () => {\n      this.clear();\n      const $input = $(this.quill.container).siblings('input[type=\"hidden\"]');\n      this.stack.undo.push({content: $input.val() || \"\", index: this.quill.getLength() - 2 });\n      this.lastLength = this.quill.getLength();\n    })\n    /* eslint-disable max-params */\n    this.quill.on(Quill.events.EDITOR_CHANGE, (eventName, delta, oldDelta, source) => {\n      if (!delta) {\n        return;\n      }\n      if (!this.init && eventName === \"selection-change\") {\n        this.stack.undo[0].index = delta.index;\n      }\n      if (eventName !== Quill.events.TEXT_CHANGE || this.ignoreChange) {\n        return;\n      }\n\n      if (!this.options.userOnly || source === Quill.sources.USER) {\n        this.record(delta, oldDelta);\n      }\n    });\n    this.quill.keyboard.addBinding({ key: \"Z\", shortKey: true }, this.undo.bind(this));\n    this.quill.keyboard.addBinding({ key: \"Z\", shortKey: true, shiftKey: true }, this.redo.bind(this));\n    if ((/Win/i).test(navigator.platform)) {\n      this.quill.keyboard.addBinding({ key: \"Y\", shortKey: true }, this.redo.bind(this));\n    }\n  }\n  /* eslint-enable max-params */\n\n  change(source, dest) {\n    if (this.stack[source].length === 0) {\n      return;\n    }\n    let obj = this.updateStacks(source, dest);\n    if (!obj.content) {\n      return;\n    }\n    if (!obj.index) {\n      obj.index = 0\n    }\n    this.lastRecorded = 0;\n    this.ignoreChange = true;\n    this.quill.setContents(this.quill.clipboard.convert(obj.content));\n    this.ignoreChange = false;\n    let index = obj.index;\n    this.quill.setSelection(index);\n  }\n\n  updateStacks(source, dest) {\n    if (source === \"undo\") {\n      if (this.stack.undo.length === 1) {\n        return this.stack.undo[0]\n      }\n      this.stack[dest].push(this.stack.undo.pop())\n      return this.stack.undo[this.stack.undo.length - 1]\n    }\n    let content = this.stack.redo.pop();\n    this.stack.undo.push(content)\n    return content\n  }\n\n  record(changeDelta) {\n    if (changeDelta.ops.length === 0) {\n      return\n    } else if (!this.init) {\n      this.init = true;\n    }\n    this.stack.redo = [];\n    let timestamp = Date.now();\n    // Should not return after length check, because after linebreak a keypress replaces invisible characters with\n    // visible characters.\n    // For example: <br><br></p> -> [press X] -> <br>X</p>.\n    if (Math.abs(this.lastLength === this.quill.getLength()) || this.lastRecorded + this.options.delay > timestamp) {\n      if (this.stack.undo.length > 1) {\n        this.stack.undo.pop();\n      }\n    } else {\n      this.lastLength = this.quill.getLength();\n      if (this.lastRecorded + this.options.delay <= timestamp) {\n        this.lastRecorded = timestamp;\n      }\n    }\n    this.stack.undo.push({content: this.quill.container.firstChild.innerHTML, index: this.quill.getSelection()})\n  }\n\n  transform() {\n    return;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}