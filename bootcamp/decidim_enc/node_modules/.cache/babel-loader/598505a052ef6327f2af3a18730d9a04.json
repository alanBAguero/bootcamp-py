{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n/* eslint id-length: [\"error\", { \"exceptions\": [\"$\"] }] */\n\n/**\n * A plain Javascript component that handles questions from polls in meetings:\n *   - fetches them via Ajax\n *   - enables a polling to automatically update them\n *\n * @class\n * @augments Component\n */\n\n// This is necessary for testing purposes\nvar $ = window.$;\n\n// Default question states\nvar OPEN = \"open\";\nvar CLOSED = \"closed\";\nvar PollComponent = /*#__PURE__*/function () {\n  function PollComponent($element, config) {\n    var $counter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    _classCallCheck(this, PollComponent);\n    this.$element = $element;\n    this.$counter = $counter;\n    this.questionsUrl = config.questionsUrl;\n    this.pollingInterval = config.pollingInterval || 5000;\n    this.mounted = false;\n    this.questions = {};\n  }\n\n  /**\n   * Returns if the component is mounted or not\n   * @public\n   * @returns {Void} - Returns nothing\n   */\n  _createClass(PollComponent, [{\n    key: \"isMounted\",\n    value: function isMounted() {\n      return this.mounted;\n    }\n\n    /**\n     * Handles the logic for mounting the component\n     * @public\n     * @returns {Void} - Returns nothing\n     */\n  }, {\n    key: \"mountComponent\",\n    value: function mountComponent() {\n      if (this.$element.length > 0 && !this.mounted) {\n        this.mounted = true;\n        this._fetchQuestions();\n      }\n    }\n  }, {\n    key: \"unmountComponent\",\n    value: function unmountComponent() {\n      if (this.mounted) {\n        this.mounted = false;\n        this._stopPolling();\n        this.$element.html(\"\");\n      }\n    }\n\n    /**\n     * Performs the ajax call that updates the list of questions\n     * Before, stores the current questions states to apply them after the ajax call has\n     * been completed\n     * @private\n     * @returns {Void} - Returns nothing\n     */\n  }, {\n    key: \"_fetchQuestions\",\n    value: function _fetchQuestions() {\n      var _this = this;\n      // Store current questions state (open / closed) before overwritting them with the Ajax call\n      // response.\n      this._storeQuestionState(this.$element);\n      $.ajax({\n        url: this.questionsUrl,\n        method: \"GET\",\n        contentType: \"application/javascript\"\n      }).done(function () {\n        _this._updateCounter();\n        _this._setQuestionsState(_this.$element);\n        _this._pollQuestions();\n      });\n    }\n\n    /**\n     * Iterates over all existing questions and stores the state in an internal attribute.\n     * @private\n     * @param {jQuery} $parent - The HTML content for the questionnaire.\n     * @returns {Void} - Returns nothing\n     */\n  }, {\n    key: \"_storeQuestionState\",\n    value: function _storeQuestionState($parent) {\n      var _this2 = this;\n      $(\"[data-question]\", $parent).each(function (_i, el) {\n        var $el = $(el);\n        var questionId = $el.data(\"question\");\n        if ($el[0].open === true) {\n          _this2.questions[questionId] = OPEN;\n        } else {\n          _this2.questions[questionId] = CLOSED;\n        }\n      });\n    }\n\n    /**\n     * Initializes the states of all the questions.\n     * @private\n     * @param {jQuery} $parent - The HTML container for the questionnaire.\n     * @returns {Void} - Returns nothing\n     */\n  }, {\n    key: \"_setQuestionsState\",\n    value: function _setQuestionsState($parent) {\n      var _this3 = this;\n      $(\"[data-question]\", $parent).each(function (_i, el) {\n        _this3._setQuestionState($(el));\n      });\n    }\n\n    /**\n     * Initializes the state of a single question with two types of modifications:\n     *   - sets the is-new class if the question is new (doesn't exist in the internal list)\n     *   - sets the state to open if it was open in the internal list\n     * @private\n     * @param {jQuery} $el - The HTML container for the questionnaire.\n     * @returns {Void} - Returns nothing\n     */\n  }, {\n    key: \"_setQuestionState\",\n    value: function _setQuestionState($el) {\n      var questionId = $el.data(\"question\");\n      // Current question state\n      var state = this.questions[questionId];\n      // New questions have a special class\n      if (!state) {\n        $el.addClass(\"is-new\");\n      } else if (state === OPEN) {\n        $el.prop(OPEN, true);\n      }\n    }\n\n    /**\n     * Sets a timeout to poll new questions.\n     * @private\n     * @returns {Void} - Returns nothing\n     */\n  }, {\n    key: \"_pollQuestions\",\n    value: function _pollQuestions() {\n      var _this4 = this;\n      this._stopPolling();\n      this.pollTimeout = setTimeout(function () {\n        _this4._fetchQuestions();\n      }, this.pollingInterval);\n    }\n\n    /**\n     * Stops polling for new questions.\n     * @private\n     * @returns {Void} - Returns nothing\n     */\n  }, {\n    key: \"_stopPolling\",\n    value: function _stopPolling() {\n      if (this.pollTimeout) {\n        clearTimeout(this.pollTimeout);\n      }\n    }\n\n    /**\n     * Updates the counter with the number of questions returned in the Ajax call\n     * @private\n     * @returns {Void} - Returns nothing\n     */\n  }, {\n    key: \"_updateCounter\",\n    value: function _updateCounter() {\n      if (this.$counter) {\n        var questionsCount = this.$element.find(\"details\").length;\n        this.$counter.html(\"(\".concat(questionsCount, \")\"));\n      }\n    }\n  }]);\n  return PollComponent;\n}();\nexport { PollComponent as default };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAMA,CAAC,GAAGC,MAAM,CAACD,CAAC;;AAElB;AACA,IAAME,IAAI,GAAG,MAAM;AACnB,IAAMC,MAAM,GAAG,QAAQ;AAAC,IAEHC,aAAa;EAChC,uBAAYC,QAAQ,EAAEC,MAAM,EAAmB;IAAA,IAAjBC,QAAQ,uEAAG,IAAI;IAAAC;IAC3C,IAAI,CAACH,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACE,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACE,YAAY,GAAGH,MAAM,CAACG,YAAY;IACvC,IAAI,CAACC,eAAe,GAAGJ,MAAM,CAACI,eAAe,IAAI,IAAI;IACrD,IAAI,CAACC,OAAO,GAAG,KAAK;IACpB,IAAI,CAACC,SAAS,GAAG,CAAC,CAAC;EACrB;;EAEA;AACF;AACA;AACA;AACA;EAJEC;IAAAC;IAAAC,OAKA,qBAAY;MACV,OAAO,IAAI,CAACJ,OAAO;IACrB;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAG;IAAAC,OAKA,0BAAiB;MACf,IAAI,IAAI,CAACV,QAAQ,CAACW,MAAM,GAAG,CAAC,IAAI,CAAC,IAAI,CAACL,OAAO,EAAE;QAC7C,IAAI,CAACA,OAAO,GAAG,IAAI;QACnB,IAAI,CAACM,eAAe,EAAE;MACxB;IACF;EAAC;IAAAH;IAAAC,OAED,4BAAmB;MACjB,IAAI,IAAI,CAACJ,OAAO,EAAE;QAChB,IAAI,CAACA,OAAO,GAAG,KAAK;QACpB,IAAI,CAACO,YAAY,EAAE;QACnB,IAAI,CAACb,QAAQ,CAACc,IAAI,CAAC,EAAE,CAAC;MACxB;IACF;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;EANE;IAAAL;IAAAC,OAOA,2BAAkB;MAAA;MAChB;MACA;MACA,IAAI,CAACK,mBAAmB,CAAC,IAAI,CAACf,QAAQ,CAAC;MAEvCL,CAAC,CAACqB,IAAI,CAAC;QACLC,GAAG,EAAE,IAAI,CAACb,YAAY;QACtBc,MAAM,EAAE,KAAK;QACbC,WAAW,EAAE;MACf,CAAC,CAAC,CAACC,IAAI,CAAC,YAAM;QACZC,KAAI,CAACC,cAAc,EAAE;QACrBD,KAAI,CAACE,kBAAkB,CAACF,KAAI,CAACrB,QAAQ,CAAC;QACtCqB,KAAI,CAACG,cAAc,EAAE;MACvB,CAAC,CAAC;IACJ;;IAEA;AACF;AACA;AACA;AACA;AACA;EALE;IAAAf;IAAAC,OAMA,6BAAoBe,OAAO,EAAE;MAAA;MAC3B9B,CAAC,CAAC,iBAAiB,EAAE8B,OAAO,CAAC,CAACC,IAAI,CAAC,UAACC,EAAE,EAAEC,EAAE,EAAK;QAC7C,IAAMC,GAAG,GAAGlC,CAAC,CAACiC,EAAE,CAAC;QACjB,IAAME,UAAU,GAAGD,GAAG,CAACE,IAAI,CAAC,UAAU,CAAC;QACvC,IAAIF,GAAG,CAAC,CAAC,CAAC,CAACG,IAAI,KAAK,IAAI,EAAE;UACxBC,MAAI,CAAC1B,SAAS,CAACuB,UAAU,CAAC,GAAGjC,IAAI;QACnC,CAAC,MAAM;UACLoC,MAAI,CAAC1B,SAAS,CAACuB,UAAU,CAAC,GAAGhC,MAAM;QACrC;MACF,CAAC,CAAC;IACJ;;IAEA;AACF;AACA;AACA;AACA;AACA;EALE;IAAAW;IAAAC,OAMA,4BAAmBe,OAAO,EAAE;MAAA;MAC1B9B,CAAC,CAAC,iBAAiB,EAAE8B,OAAO,CAAC,CAACC,IAAI,CAAC,UAACC,EAAE,EAAEC,EAAE,EAAK;QAC7CM,MAAI,CAACC,iBAAiB,CAACxC,CAAC,CAACiC,EAAE,CAAC,CAAC;MAC/B,CAAC,CAAC;IACJ;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAAnB;IAAAC,OAQA,2BAAkBmB,GAAG,EAAE;MACrB,IAAMC,UAAU,GAAGD,GAAG,CAACE,IAAI,CAAC,UAAU,CAAC;MACvC;MACA,IAAMK,KAAK,GAAG,IAAI,CAAC7B,SAAS,CAACuB,UAAU,CAAC;MACxC;MACA,IAAI,CAACM,KAAK,EAAE;QACVP,GAAG,CAACQ,QAAQ,CAAC,QAAQ,CAAC;MACxB,CAAC,MAAM,IAAID,KAAK,KAAKvC,IAAI,EAAE;QACzBgC,GAAG,CAACS,IAAI,CAACzC,IAAI,EAAE,IAAI,CAAC;MACtB;IACF;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAY;IAAAC,OAKA,0BAAiB;MAAA;MACf,IAAI,CAACG,YAAY,EAAE;MAEnB,IAAI,CAAC0B,WAAW,GAAGC,UAAU,CAAC,YAAM;QAClCC,MAAI,CAAC7B,eAAe,EAAE;MACxB,CAAC,EAAE,IAAI,CAACP,eAAe,CAAC;IAC1B;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAI;IAAAC,OAKA,wBAAe;MACb,IAAI,IAAI,CAAC6B,WAAW,EAAE;QACpBG,YAAY,CAAC,IAAI,CAACH,WAAW,CAAC;MAChC;IACF;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAA9B;IAAAC,OAKA,0BAAiB;MACf,IAAI,IAAI,CAACR,QAAQ,EAAE;QACjB,IAAMyC,cAAc,GAAG,IAAI,CAAC3C,QAAQ,CAAC4C,IAAI,CAAC,SAAS,CAAC,CAACjC,MAAM;QAC3D,IAAI,CAACT,QAAQ,CAACY,IAAI,YAAK6B,cAAc,OAAI;MAC3C;IACF;EAAC;EAAA;AAAA;AAAA,SAlJkB5C,aAAa","names":["$","window","OPEN","CLOSED","PollComponent","$element","config","$counter","_classCallCheck","questionsUrl","pollingInterval","mounted","questions","_createClass","key","value","length","_fetchQuestions","_stopPolling","html","_storeQuestionState","ajax","url","method","contentType","done","_this","_updateCounter","_setQuestionsState","_pollQuestions","$parent","each","_i","el","$el","questionId","data","open","_this2","_this3","_setQuestionState","state","addClass","prop","pollTimeout","setTimeout","_this4","clearTimeout","questionsCount","find"],"sources":["/home/alan/.rvm/gems/ruby-3.0.3/gems/decidim-meetings-0.27.0/app/packs/src/decidim/meetings/poll.component.js"],"sourcesContent":["/* eslint id-length: [\"error\", { \"exceptions\": [\"$\"] }] */\n\n/**\n * A plain Javascript component that handles questions from polls in meetings:\n *   - fetches them via Ajax\n *   - enables a polling to automatically update them\n *\n * @class\n * @augments Component\n */\n\n// This is necessary for testing purposes\nconst $ = window.$;\n\n// Default question states\nconst OPEN = \"open\";\nconst CLOSED = \"closed\";\n\nexport default class PollComponent {\n  constructor($element, config, $counter = null) {\n    this.$element = $element;\n    this.$counter = $counter;\n    this.questionsUrl = config.questionsUrl;\n    this.pollingInterval = config.pollingInterval || 5000;\n    this.mounted = false;\n    this.questions = {};\n  }\n\n  /**\n   * Returns if the component is mounted or not\n   * @public\n   * @returns {Void} - Returns nothing\n   */\n  isMounted() {\n    return this.mounted;\n  }\n\n  /**\n   * Handles the logic for mounting the component\n   * @public\n   * @returns {Void} - Returns nothing\n   */\n  mountComponent() {\n    if (this.$element.length > 0 && !this.mounted) {\n      this.mounted = true;\n      this._fetchQuestions();\n    }\n  }\n\n  unmountComponent() {\n    if (this.mounted) {\n      this.mounted = false;\n      this._stopPolling();\n      this.$element.html(\"\");\n    }\n  }\n\n  /**\n   * Performs the ajax call that updates the list of questions\n   * Before, stores the current questions states to apply them after the ajax call has\n   * been completed\n   * @private\n   * @returns {Void} - Returns nothing\n   */\n  _fetchQuestions() {\n    // Store current questions state (open / closed) before overwritting them with the Ajax call\n    // response.\n    this._storeQuestionState(this.$element);\n\n    $.ajax({\n      url: this.questionsUrl,\n      method: \"GET\",\n      contentType: \"application/javascript\"\n    }).done(() => {\n      this._updateCounter();\n      this._setQuestionsState(this.$element);\n      this._pollQuestions();\n    });\n  }\n\n  /**\n   * Iterates over all existing questions and stores the state in an internal attribute.\n   * @private\n   * @param {jQuery} $parent - The HTML content for the questionnaire.\n   * @returns {Void} - Returns nothing\n   */\n  _storeQuestionState($parent) {\n    $(\"[data-question]\", $parent).each((_i, el) => {\n      const $el = $(el);\n      const questionId = $el.data(\"question\");\n      if ($el[0].open === true) {\n        this.questions[questionId] = OPEN;\n      } else {\n        this.questions[questionId] = CLOSED;\n      }\n    });\n  }\n\n  /**\n   * Initializes the states of all the questions.\n   * @private\n   * @param {jQuery} $parent - The HTML container for the questionnaire.\n   * @returns {Void} - Returns nothing\n   */\n  _setQuestionsState($parent) {\n    $(\"[data-question]\", $parent).each((_i, el) => {\n      this._setQuestionState($(el));\n    });\n  }\n\n  /**\n   * Initializes the state of a single question with two types of modifications:\n   *   - sets the is-new class if the question is new (doesn't exist in the internal list)\n   *   - sets the state to open if it was open in the internal list\n   * @private\n   * @param {jQuery} $el - The HTML container for the questionnaire.\n   * @returns {Void} - Returns nothing\n   */\n  _setQuestionState($el) {\n    const questionId = $el.data(\"question\");\n    // Current question state\n    const state = this.questions[questionId];\n    // New questions have a special class\n    if (!state) {\n      $el.addClass(\"is-new\");\n    } else if (state === OPEN) {\n      $el.prop(OPEN, true);\n    }\n  }\n\n  /**\n   * Sets a timeout to poll new questions.\n   * @private\n   * @returns {Void} - Returns nothing\n   */\n  _pollQuestions() {\n    this._stopPolling();\n\n    this.pollTimeout = setTimeout(() => {\n      this._fetchQuestions();\n    }, this.pollingInterval);\n  }\n\n  /**\n   * Stops polling for new questions.\n   * @private\n   * @returns {Void} - Returns nothing\n   */\n  _stopPolling() {\n    if (this.pollTimeout) {\n      clearTimeout(this.pollTimeout);\n    }\n  }\n\n  /**\n   * Updates the counter with the number of questions returned in the Ajax call\n   * @private\n   * @returns {Void} - Returns nothing\n   */\n  _updateCounter() {\n    if (this.$counter) {\n      const questionsCount = this.$element.find(\"details\").length;\n      this.$counter.html(`(${questionsCount})`);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}